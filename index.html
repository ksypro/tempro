<!doctype html>
<html lang="zh-Hant">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
    <meta name="theme-color" content="#0B0F17" />
    <meta name="color-scheme" content="dark" />

    <link rel="manifest" href="./manifest.webmanifest" />
    <link rel="icon" href="./icons/icon-192.svg" type="image/svg+xml" />
    <link rel="apple-touch-icon" href="./icons/icon-192.svg" />

    <title>RAP FLOW COACH v0.8.5</title>

    <style>
      :root {
        --bg: #0b0f17;
        --panel: rgba(255, 255, 255, 0.06);
        --panel2: rgba(255, 255, 255, 0.09);
        --text: rgba(255, 255, 255, 0.92);
        --muted: rgba(255, 255, 255, 0.68);
        --muted2: rgba(255, 255, 255, 0.55);
        --line: rgba(255, 255, 255, 0.12);
        --accent: #00E5FF;
        --accent2: #FFFFFF;
        --good: #00E5FF;
        --warn: #fbbf24;
        --danger: #fb7185;
        --amber: #fbbf24;
        --success: #34d399;

        --radius: 18px;
        --radius2: 14px;
        --shadow: 0 16px 40px rgba(0, 0, 0, 0.45);
        --safe-top: env(safe-area-inset-top, 0px);
        --safe-bottom: env(safe-area-inset-bottom, 0px);
        --safe-left: env(safe-area-inset-left, 0px);
        --safe-right: env(safe-area-inset-right, 0px);
      }

      * { box-sizing: border-box; }
      html, body { height: 100%; }
      body {
        margin: 0;
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans TC", "PingFang TC", "Heiti TC", Arial, sans-serif;
        background: radial-gradient(1200px 700px at 50% -10%, rgba(0, 229, 255, 0.18), transparent 60%),
                    radial-gradient(900px 500px at 10% 20%, rgba(0, 229, 255, 0.12), transparent 55%),
                    var(--bg);
        color: var(--text);
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
      }

      button, input {
        font: inherit;
        color: inherit;
      }

      .app {
        min-height: 100%;
        display: flex;
        flex-direction: column;
        gap: 14px;
        padding: calc(16px + var(--safe-top)) calc(16px + var(--safe-right)) calc(18px + var(--safe-bottom)) calc(16px + var(--safe-left));
        max-width: 740px;
        margin: 0 auto;
      }

      header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
      }

      .brand {
        display: flex;
        flex-direction: column;
        gap: 2px;
      }
      .brand .title {
        font-weight: 700;
        letter-spacing: 0.2px;
        font-size: 16px;
        color: var(--text);
      }
      .brand .subtitle {
        font-size: 12px;
        color: var(--muted);
        display: none;
      }

      .pill {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        padding: 10px 12px;
        border-radius: 999px;
        background: var(--panel);
        border: 1px solid var(--line);
        box-shadow: 0 8px 22px rgba(0,0,0,0.25);
        white-space: nowrap;
        flex-shrink: 0;
      }

      .pill .dot {
        width: 9px;
        height: 9px;
        border-radius: 50%;
        background: var(--muted2);
        flex-shrink: 0;
      }
      .pill[data-state="playing"] .dot { background: var(--good); }
      .pill[data-state="paused"] .dot { background: var(--warn); }
      .pill .stateText {
        font-size: 12px;
        color: var(--muted);
        user-select: none;
        white-space: nowrap;
      }
      
      .calendarBtn {
        padding: 10px 12px;
        font-size: 18px;
        background: rgba(255,255,255,0.08);
        border: 1px solid var(--line);
        border-radius: 999px;
        cursor: pointer;
        transition: all 0.2s;
        touch-action: manipulation;
        user-select: none;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .calendarBtn:hover {
        background: rgba(255,255,255,0.12);
        border-color: rgba(255,255,255,0.2);
      }
      .calendarBtn:active {
        background: rgba(0,229,255,0.2);
        border-color: rgba(0,229,255,0.4);
        transform: scale(0.95);
      }
      
      .calendarModal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0,0,0,0.75);
        z-index: 1000;
        align-items: center;
        justify-content: center;
        padding: 20px;
        overflow-y: auto;
      }
      .calendarModal.show {
        display: flex;
      }
      .calendarContent {
        background: var(--bg);
        border: 1px solid var(--line);
        border-radius: var(--radius);
        max-width: 600px;
        width: 100%;
        max-height: 90vh;
        overflow-y: auto;
        box-shadow: var(--shadow);
      }
      .calendarHeader {
        padding: 16px;
        border-bottom: 1px solid var(--line);
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      .calendarHeader h2 {
        margin: 0;
        font-size: 18px;
        font-weight: 700;
      }
      .calendarCloseBtn {
        padding: 6px 12px;
        font-size: 14px;
        background: rgba(255,255,255,0.08);
        border: 1px solid var(--line);
        border-radius: 6px;
        cursor: pointer;
        transition: all 0.2s;
      }
      .calendarCloseBtn:hover {
        background: rgba(255,255,255,0.12);
      }
      .calendarBody {
        padding: 16px;
      }
      .calendarNav {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 16px;
      }
      .calendarNavBtn {
        padding: 8px 16px;
        font-size: 14px;
        background: rgba(255,255,255,0.08);
        border: 1px solid var(--line);
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.2s;
      }
      .calendarNavBtn:hover {
        background: rgba(255,255,255,0.12);
      }
      .calendarMonthYear {
        font-size: 16px;
        font-weight: 600;
      }
      .calendarGrid {
        display: grid;
        grid-template-columns: repeat(7, 1fr);
        gap: 4px;
        margin-bottom: 16px;
      }
      .calendarDayHeader {
        padding: 8px;
        text-align: center;
        font-size: 12px;
        font-weight: 600;
        color: var(--muted);
      }
      .calendarDay {
        aspect-ratio: 1;
        padding: 6px 4px;
        border: 1px solid var(--line);
        border-radius: 6px;
        cursor: pointer;
        transition: all 0.2s;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: flex-start;
        position: relative;
        background: rgba(255,255,255,0.03);
        min-height: 0;
      }
      .calendarDay:hover {
        background: rgba(255,255,255,0.08);
        border-color: rgba(0,229,255,0.3);
      }
      .calendarDay.otherMonth {
        opacity: 0.3;
      }
      .calendarDay.today {
        border-color: rgba(0,229,255,0.5);
        background: rgba(0,229,255,0.1);
      }
      .calendarDay.hasTraining {
        background: rgba(0,229,255,0.2);
        border-color: rgba(0,229,255,0.5);
      }
      .calendarDay.goalAchieved {
        background: rgba(52,211,153,0.25);
        border-color: rgba(52,211,153,0.6);
        box-shadow: 0 0 0 2px rgba(52,211,153,0.3);
      }
      .calendarDay.goalAchieved .calendarDayNumber {
        color: var(--success);
      }
      .calendarDay.goalAchieved .calendarDaySessions,
      .calendarDay.goalAchieved .calendarDayDuration {
        color: rgba(52,211,153,0.9);
      }
      .calendarDayNumber {
        font-size: 13px;
        font-weight: 700;
        line-height: 1.2;
        margin-bottom: 2px;
      }
      .calendarDaySessions {
        font-size: 9px;
        font-weight: 700;
        color: var(--accent);
        line-height: 1.2;
        text-align: center;
        margin-bottom: 2px;
      }
      .calendarDayDuration {
        font-size: 9px;
        font-weight: 600;
        color: var(--text);
        line-height: 1.2;
        text-align: center;
      }
      .calendarStats {
        padding: 12px;
        background: rgba(255,255,255,0.05);
        border-radius: 8px;
        margin-bottom: 16px;
      }
      .calendarStatsTitle {
        font-size: 12px;
        font-weight: 600;
        color: var(--muted);
        margin-bottom: 8px;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }
      .calendarStatsGrid {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 12px;
        margin-bottom: 16px;
      }
      .calendarStatItem {
        display: flex;
        flex-direction: column;
        gap: 4px;
      }
      .calendarStatLabel {
        font-size: 11px;
        color: var(--muted2);
      }
      .calendarStatValue {
        font-size: 18px;
        font-weight: 700;
        color: var(--accent);
      }
      .calendarBpmStatsSection {
        grid-column: 1 / -1;
        margin-top: 8px;
        padding-top: 12px;
        border-top: 1px solid var(--line);
      }
      .calendarBpmStatsTitle {
        font-size: 11px;
        font-weight: 600;
        color: var(--muted);
        margin-bottom: 8px;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }
      .calendarBpmStatsGrid {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 8px;
      }
      .calendarBpmStatItem {
        display: flex;
        flex-direction: column;
        gap: 2px;
        padding: 6px;
        background: rgba(255,255,255,0.03);
        border-radius: 4px;
      }
      .calendarBpmStatLabel {
        font-size: 10px;
        color: var(--muted2);
      }
      .calendarBpmStatValue {
        font-size: 13px;
        font-weight: 600;
        color: var(--accent);
      }
      .calendarDayDetail {
        margin-top: 20px;
        padding-top: 20px;
        border-top: 2px solid var(--line);
      }
      .calendarDayDetailTitle {
        font-size: 18px;
        font-weight: 700;
        margin-bottom: 16px;
        color: var(--text);
        letter-spacing: 0.3px;
      }
      .calendarSessionList {
        display: flex;
        flex-direction: column;
        gap: 8px;
      }
      .calendarDayDetailSummary {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 12px;
        margin-bottom: 16px;
        padding: 12px;
        background: rgba(255,255,255,0.05);
        border-radius: 8px;
      }
      .calendarDayDetailSummaryItem {
        display: flex;
        flex-direction: column;
        gap: 4px;
      }
      .calendarDayDetailSummaryLabel {
        font-size: 11px;
        color: var(--muted2);
      }
      .calendarDayDetailSummaryValue {
        font-size: 16px;
        font-weight: 700;
        color: var(--accent);
      }
      .calendarSessionGroup {
        margin-bottom: 24px;
      }
      .calendarSessionGroup:last-child {
        margin-bottom: 0;
      }
      .calendarSessionGroupTitle {
        font-size: 14px;
        font-weight: 700;
        color: var(--accent);
        margin-bottom: 12px;
        padding-bottom: 8px;
        border-bottom: 2px solid rgba(0,229,255,0.3);
        display: flex;
        align-items: center;
        gap: 8px;
      }
      .calendarSessionGroupTitle::before {
        content: '';
        width: 3px;
        height: 16px;
        background: var(--accent);
        border-radius: 2px;
      }
      .calendarSessionItem {
        padding: 14px;
        background: rgba(255,255,255,0.06);
        border: 1px solid rgba(255,255,255,0.1);
        border-radius: 8px;
        font-size: 12px;
        margin-bottom: 10px;
        transition: all 0.2s;
        position: relative;
      }
      .calendarSessionItem:hover {
        background: rgba(255,255,255,0.08);
        border-color: rgba(0,229,255,0.3);
        transform: translateY(-1px);
      }
      .calendarSessionItem:last-child {
        margin-bottom: 0;
      }
      .calendarSessionHeader {
        display: flex;
        justify-content: flex-end;
        align-items: center;
        margin-bottom: 10px;
      }
      .calendarSessionDuration {
        color: var(--accent);
        font-weight: 700;
        font-size: 18px;
        line-height: 1.2;
        white-space: nowrap;
        background: rgba(0,229,255,0.12);
        padding: 6px 14px;
        border-radius: 8px;
        border: 1px solid rgba(0,229,255,0.25);
      }
      .calendarBpmRangeSection {
        margin-top: 20px;
        margin-bottom: 20px;
        padding-top: 20px;
        border-top: 2px solid var(--line);
      }
      .calendarBpmRangeTitle {
        font-size: 13px;
        font-weight: 700;
        color: var(--accent);
        margin-bottom: 12px;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }
      .calendarBpmRangeGrid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
        gap: 10px;
      }
      .calendarBpmRangeItem {
        padding: 10px;
        background: rgba(255,255,255,0.05);
        border: 1px solid rgba(255,255,255,0.1);
        border-radius: 6px;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 4px;
        transition: all 0.2s;
      }
      .calendarBpmRangeItem:hover {
        background: rgba(255,255,255,0.08);
        border-color: rgba(0,229,255,0.3);
        transform: translateY(-1px);
      }
      .calendarBpmRangeItem.bpmRangeAmber {
        border-color: rgba(251,191,36,0.4);
        background: rgba(251,191,36,0.08);
      }
      .calendarBpmRangeItem.bpmRangeAmber:hover {
        border-color: rgba(251,191,36,0.6);
        background: rgba(251,191,36,0.12);
      }
      .calendarBpmRangeItem.bpmRangeGreen {
        border-color: rgba(52,211,153,0.4);
        background: rgba(52,211,153,0.08);
      }
      .calendarBpmRangeItem.bpmRangeGreen:hover {
        border-color: rgba(52,211,153,0.6);
        background: rgba(52,211,153,0.12);
      }
      .calendarBpmRangeLabel {
        font-size: 11px;
        font-weight: 600;
        color: var(--muted);
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }
      .calendarBpmRangeValue {
        font-size: 16px;
        font-weight: 700;
        color: var(--accent);
        line-height: 1.2;
      }
      .calendarBpmRangeItem.bpmRangeAmber .calendarBpmRangeValue {
        color: var(--amber);
      }
      .calendarBpmRangeItem.bpmRangeGreen .calendarBpmRangeValue {
        color: var(--success);
      }
      .calendarBpmRangeCount {
        font-size: 10px;
        color: var(--muted2);
        margin-top: 2px;
      }
      .calendarBpmRangeItem.bpmRangeAmber .calendarBpmRangeCount {
        color: rgba(251,191,36,0.8);
      }
      .calendarBpmRangeItem.bpmRangeGreen .calendarBpmRangeCount {
        color: rgba(52,211,153,0.8);
      }
      
      .dailyGoalHeader {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 10px;
      }
      .dailyGoalTitle {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 13px;
        font-weight: 600;
        color: var(--text);
      }
      .dailyGoalProgressInfo {
        display: flex;
        align-items: baseline;
        gap: 8px;
        font-size: 12px;
      }
      .dailyGoalProgressInfo span:first-child {
        color: var(--text);
        font-weight: 600;
      }
      .dailyGoalProgressInfo span:last-child {
        color: var(--accent);
        font-weight: 700;
        font-size: 14px;
      }
      .dailyGoalProgressBar {
        width: 100%;
        height: 8px;
        background: rgba(255,255,255,0.08);
        border-radius: 999px;
        overflow: hidden;
        position: relative;
      }
      .dailyGoalProgressFill {
        height: 100%;
        background: linear-gradient(90deg, rgba(0,229,255,0.6), rgba(0,229,255,0.8));
        border-radius: 999px;
        transition: width 0.3s ease-out;
        width: 0%;
      }
      .dailyGoalProgressFill.complete {
        background: linear-gradient(90deg, rgba(52,211,153,0.6), rgba(52,211,153,0.8));
      }
      .calendarDailyGoal {
        padding: 12px;
        background: rgba(255,255,255,0.05);
        border-radius: 8px;
        margin-bottom: 16px;
        border: 1px solid var(--line);
      }
      .calendarDailyGoalHeader {
        display: flex;
        justify-content: flex-start;
        align-items: center;
        margin-bottom: 8px;
      }
      .calendarDailyGoalTitle {
        font-size: 12px;
        font-weight: 600;
        color: var(--muted);
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }
      .calendarSessionInfo {
        display: flex;
        flex-wrap: wrap;
        gap: 12px 16px;
        margin-bottom: 8px;
      }
      .calendarSessionInfoItem {
        display: flex;
        align-items: baseline;
        gap: 6px;
        min-width: 0;
      }
      .calendarSessionInfoLabel {
        font-size: 10px;
        color: var(--muted2);
        font-weight: 500;
        white-space: nowrap;
      }
      .calendarSessionInfoValue {
        font-size: 13px;
        color: var(--text);
        font-weight: 700;
        white-space: nowrap;
      }
      .calendarSessionTags {
        display: flex;
        gap: 6px;
        flex-wrap: wrap;
        margin-top: 8px;
        padding-top: 8px;
        border-top: 1px solid rgba(255,255,255,0.08);
      }
      .calendarSessionTag {
        padding: 3px 8px;
        background: rgba(0,229,255,0.12);
        border: 1px solid rgba(0,229,255,0.25);
        border-radius: 5px;
        font-size: 9px;
        color: var(--accent);
        font-weight: 600;
        letter-spacing: 0.3px;
      }

      .grid {
        display: grid;
        gap: 14px;
      }

      .card {
        background: linear-gradient(180deg, rgba(255,255,255,0.08), rgba(255,255,255,0.05));
        border: 1px solid var(--line);
        border-radius: var(--radius);
        box-shadow: var(--shadow);
        overflow: hidden;
      }

      .cardInner {
        padding: 14px;
        position: relative;
      }

      .bpmRow {
        display: flex;
        flex-direction: column;
        gap: 8px;
        align-items: center;
      }

      .bpmBig {
        display: flex;
        flex-direction: column;
        gap: 4px;
        min-width: 0;
        align-items: center;
        text-align: center;
        position: relative;
        transition: all 0.15s ease-out;
      }
      .bpmBig .label {
        font-size: 12px;
        color: var(--muted);
      }
      .bpmBig .valueRow {
        display: flex;
        align-items: baseline;
        gap: 10px;
        user-select: none;
        touch-action: manipulation;
      }
      .bpmBig .value {
        font-size: 44px;
        font-weight: 800;
        letter-spacing: -0.8px;
        line-height: 1;
      }
      .bpmBig .unit {
        font-size: 14px;
        color: var(--muted);
        font-weight: 600;
      }
      .tapTempoBtn {
        margin-top: 12px;
        padding: 10px 24px;
        font-size: 13px;
        font-weight: 600;
        color: var(--text);
        background: rgba(255,255,255,0.08);
        border: 1px solid var(--line);
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.2s;
        touch-action: manipulation;
        user-select: none;
        width: 100%;
      }
      .tapTempoBtn:hover {
        background: rgba(255,255,255,0.12);
        border-color: rgba(255,255,255,0.2);
      }
      .tapTempoBtn:active {
        background: rgba(0,229,255,0.2);
        border-color: rgba(0,229,255,0.4);
        transform: scale(0.98);
      }
      .bpmSliderRow {
        margin-top: 10px;
        width: 100%;
      }
      .bpmSliderRow input[type="range"] {
        width: 100%;
        appearance: none;
        height: 4px;
        border-radius: 999px;
        background: linear-gradient(90deg, rgba(0,229,255,0.45), rgba(255,255,255,0.40));
        outline: none;
      }
      .bpmSliderRow input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 18px;
        height: 18px;
        border-radius: 50%;
        background: #0b0f17;
        border: 2px solid rgba(0,229,255,0.90);
        box-shadow: 0 0 0 4px rgba(0,229,255,0.28);
        cursor: pointer;
      }
      .bpmSliderRow input[type="range"]::-moz-range-thumb {
        width: 18px;
        height: 18px;
        border-radius: 50%;
        background: #0b0f17;
        border: 2px solid rgba(0,229,255,0.90);
        box-shadow: 0 0 0 4px rgba(0,229,255,0.28);
        cursor: pointer;
      }
      .bpmSliderRow input[type="range"]::-webkit-slider-runnable-track {
        height: 4px;
        border-radius: 999px;
        background: transparent;
      }
      .bpmSliderRow input[type="range"]::-moz-range-track {
        height: 4px;
        border-radius: 999px;
        background: transparent;
      }

      .swingRow {
        margin-top: 16px;
        padding-top: 16px;
        border-top: 1px solid var(--line);
        display: flex;
        align-items: center;
        gap: 12px;
      }
      .swingRow .label {
        font-size: 13px;
        font-weight: 700;
        color: var(--text);
        letter-spacing: 0.2px;
        flex-shrink: 0;
      }
      .swingRow .value {
        font-size: 13px;
        font-weight: 800;
        color: var(--accent2);
        font-variant-numeric: tabular-nums;
        flex-shrink: 0;
        min-width: 36px;
        text-align: right;
      }
      .swingSliderRow {
        flex: 1;
        min-width: 0;
      }
      .swingSliderRow input[type="range"] {
        width: 100%;
        appearance: none;
        height: 4px;
        border-radius: 999px;
        background: linear-gradient(90deg, rgba(255,255,255,0.45), rgba(0,229,255,0.40));
        outline: none;
      }
      .swingSliderRow input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 18px;
        height: 18px;
        border-radius: 50%;
        background: #0b0f17;
        border: 2px solid rgba(255,255,255,0.90);
        box-shadow: 0 0 0 4px rgba(255,255,255,0.28);
        cursor: pointer;
      }
      .swingSliderRow input[type="range"]::-moz-range-thumb {
        width: 18px;
        height: 18px;
        border-radius: 50%;
        background: #0b0f17;
        border: 2px solid rgba(255,255,255,0.90);
        box-shadow: 0 0 0 4px rgba(255,255,255,0.28);
        cursor: pointer;
      }
      .swingSliderRow input[type="range"]::-webkit-slider-runnable-track {
        height: 4px;
        border-radius: 999px;
        background: transparent;
      }
      .swingSliderRow input[type="range"]::-moz-range-track {
        height: 4px;
        border-radius: 999px;
        background: transparent;
      }

      .sectionLabel {
        font-size: 11px;
        color: var(--muted2);
        text-transform: uppercase;
        letter-spacing: 1px;
        margin-bottom: 6px;
      }

      .controlsRow {
        display: grid;
        grid-template-columns: 1fr;
        gap: 10px;
        margin-top: 12px;
      }

      .bigButton {
        min-height: 64px;
        border-radius: 16px;
        border: 1px solid var(--line);
        background: rgba(255,255,255,0.06);
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 10px;
        cursor: pointer;
        touch-action: manipulation;
        user-select: none;
        font-weight: 900;
        letter-spacing: 0.8px;
      }
      .bigButton.playing {
        background: linear-gradient(180deg, rgba(0,229,255,0.20), rgba(0,229,255,0.08));
        border-color: rgba(0,229,255,0.22);
      }
      .bigButton .small {
        font-weight: 700;
        letter-spacing: 0.2px;
        font-size: 12px;
        color: var(--muted);
      }

      .seg,
      .grooveSeg {
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        gap: 8px;
        margin-top: 12px;
      }
      .seg button,
      .grooveSeg button {
        padding: 12px 10px;
        border-radius: 14px;
        border: 1px solid var(--line);
        background: rgba(255,255,255,0.05);
        cursor: pointer;
        touch-action: manipulation;
        user-select: none;
        font-weight: 800;
        letter-spacing: 0.2px;
      }
      .seg button[aria-pressed="true"],
      .grooveSeg button[aria-pressed="true"] {
        background: linear-gradient(180deg, rgba(0,229,255,0.22), rgba(0,229,255,0.10));
        border-color: rgba(0,229,255,0.26);
      }
      .segNote {
        margin-top: 10px;
        font-size: 12px;
        color: var(--muted);
        min-height: 18px;
      }

      .ghostModeRow {
        position: absolute;
        top: 14px;
        right: 14px;
        display: flex;
        align-items: center;
        gap: 8px;
      }
      .ghostModeRow .label {
        font-size: 12px;
        font-weight: 700;
        color: var(--text);
        letter-spacing: 0.2px;
      }

      .progressiveModeRow {
        position: absolute;
        top: 50px;
        right: 14px;
        display: flex;
        align-items: center;
        gap: 8px;
      }
      .progressiveModeRow .label {
        font-size: 12px;
        font-weight: 700;
        color: var(--text);
        letter-spacing: 0.2px;
      }



      .toggleSwitch {
        position: relative;
        width: 50px;
        height: 28px;
        flex-shrink: 0;
      }
      .toggleSwitch input {
        opacity: 0;
        width: 0;
        height: 0;
      }
      .toggleSwitch .slider {
        position: absolute;
        cursor: pointer;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(255,255,255,0.12);
        border: 1px solid var(--line);
        border-radius: 999px;
        transition: 0.25s;
      }
      .toggleSwitch .slider:before {
        position: absolute;
        content: "";
        height: 20px;
        width: 20px;
        left: 3px;
        bottom: 3px;
        background: rgba(255,255,255,0.85);
        border-radius: 50%;
        transition: 0.25s;
        box-shadow: 0 2px 4px rgba(0,0,0,0.2);
      }
      .toggleSwitch input:checked + .slider {
        background: linear-gradient(180deg, rgba(0,229,255,0.35), rgba(0,229,255,0.20));
        border-color: rgba(0,229,255,0.40);
      }
      .toggleSwitch input:checked + .slider:before {
        transform: translateX(22px);
        background: var(--accent);
      }

      .timelineWrap {
        padding: 14px;
      }
      .timelineHeader {
        display: flex;
        align-items: flex-end;
        justify-content: space-between;
        gap: 12px;
        margin-bottom: 10px;
      }
      .timelineHeader .left {
        display: flex;
        flex-direction: column;
        gap: 4px;
      }
      .timelineHeader .left .title {
        font-weight: 800;
        letter-spacing: 0.2px;
        display: none;
      }
      .timelineHeader .left .meta {
        font-size: 12px;
        color: var(--muted);
      }
      .timelineHeader .right {
        font-size: 12px;
        color: var(--muted);
        text-align: right;
      }

      canvas {
        width: 100%;
        height: 110px;
        display: block;
        border-radius: 16px;
        background: rgba(0,0,0,0.18);
        border: 1px solid rgba(255,255,255,0.10);
      }

      details {
        border-top: 1px solid rgba(255,255,255,0.10);
        margin-top: 12px;
        padding-top: 12px;
      }
      summary {
        cursor: pointer;
        user-select: none;
        color: var(--muted);
        font-weight: 700;
        list-style: none;
      }
      summary::-webkit-details-marker { display: none; }

      .sliders {
        margin-top: 12px;
        display: grid;
        gap: 10px;
      }
      .sliderRow {
        display: grid;
        grid-template-columns: 108px 1fr 44px;
        gap: 10px;
        align-items: center;
      }
      .sliderRow .name {
        font-size: 12px;
        color: var(--muted);
      }
      .sliderRow input[type="range"] {
        width: 100%;
      }
      .sliderRow .val {
        font-variant-numeric: tabular-nums;
        font-size: 12px;
        color: var(--muted);
        text-align: right;
      }

      .footer {
        margin-top: auto;
        padding-top: 6px;
        color: var(--muted2);
        font-size: 12px;
        line-height: 1.35;
        display: none;
      }
      .footer a { color: var(--accent); text-decoration: none; }

      .toast {
        position: fixed;
        left: 50%;
        bottom: calc(16px + var(--safe-bottom));
        transform: translateX(-50%);
        background: rgba(0,0,0,0.70);
        color: rgba(255,255,255,0.92);
        padding: 10px 12px;
        border-radius: 12px;
        border: 1px solid rgba(255,255,255,0.14);
        box-shadow: 0 16px 40px rgba(0,0,0,0.40);
        max-width: min(520px, calc(100% - 24px));
        display: none;
        font-size: 12px;
      }
      .toast.show { display: block; }

      @media (max-width: 420px) {
        .bpmBtns { min-width: 150px; }
        .bpmBig .value { font-size: 40px; }
        canvas { height: 104px; }
      }
    </style>
  </head>

  <body>
    <div class="app">
      <header>
        <div class="brand">
          <div class="title">RAP FLOW COACH</div>
          <div class="subtitle">iPhone Safari å‹å–„ Â· ç²¾æº–æ’ç¨‹ Â· é›¢ç·šå¯ç”¨</div>
        </div>
        <div style="display: flex; gap: 8px; align-items: center; flex-shrink: 0;">
          <button type="button" class="calendarBtn" id="calendarBtn" aria-label="æŸ¥çœ‹è¨“ç·´æ—¥æ›†">
            <span>ğŸ“…</span>
          </button>
          <div id="statePill" class="pill" data-state="stopped" role="status" aria-live="polite">
            <span class="dot" aria-hidden="true"></span>
            <span class="stateText" id="stateText">STANDBY</span>
          </div>
        </div>
      </header>

      <!-- Daily Goal Progress -->
      <section class="card" id="dailyGoalCard">
        <div class="cardInner">
          <div class="dailyGoalHeader">
            <div class="dailyGoalTitle">
              <span>ä»Šæ—¥ç›®æ¨™ï¼ˆ20åˆ†é˜ï¼‰</span>
            </div>
            <div class="dailyGoalProgressInfo" id="dailyGoalProgressInfo">
              <span id="dailyGoalProgressText">0 / 20 åˆ†é˜</span>
              <span id="dailyGoalProgressPercent">0%</span>
            </div>
          </div>
          <div class="dailyGoalProgressBar">
            <div class="dailyGoalProgressFill" id="dailyGoalProgressFill"></div>
          </div>
        </div>
      </section>

      <div class="grid">
        <section class="card">
          <div class="timelineWrap">
            <div class="sectionLabel">TIMELINE</div>
            <div class="timelineHeader">
              <div class="left">
                <div class="title">BEAT MATRIX (ç¯€æ‹çŸ©é™£)</div>
                <div class="meta" id="timelineMeta">4/4 Â· 1/4 Â· Bar 1</div>
              </div>
            </div>
            <canvas id="timeline" width="900" height="220" aria-label="è¦–è¦ºæ™‚é–“è»¸"></canvas>
          </div>
        </section>

        <section class="card">
          <div class="cardInner">
            <div class="sectionLabel">TEMPO &amp; SUBDIVISION</div>
            <div class="bpmRow">
              <div class="bpmBig" id="bpmDrag" aria-label="BPM èª¿æ•´å€ï¼ˆå¯å·¦å³æ»‘å‹•èª¿æ•´ï¼‰">
                <div class="valueRow">
                  <div class="value" id="bpmValue">92</div>
                  <div class="unit">BPM</div>
                </div>
              </div>
              <div class="bpmSliderRow">
                <input id="bpmSlider" type="range" min="40" max="240" step="1" value="92" aria-label="BPM æ©«æ¡¿èª¿æ•´" />
              </div>
              <button type="button" class="tapTempoBtn" id="tapTempoBtn" aria-label="Tap Tempo æ‹é€Ÿæª¢æ¸¬">
                <span>TAP</span>
              </button>
            </div>

            <div class="swingRow">
              <div class="label">Groove</div>
              <div class="swingSliderRow">
                <input id="swingSlider" type="range" min="0" max="100" step="1" value="0" aria-label="Groove èª¿æ•´" />
              </div>
              <div class="value" id="swingValue">0%</div>
            </div>


            <div class="seg" role="group" aria-label="ç¯€å¥ç´°åˆ†æ§åˆ¶">
              <button type="button" class="segBtn" data-division="1" aria-pressed="true">1/4</button>
              <button type="button" class="segBtn" data-division="2" aria-pressed="false">1/8</button>
              <button type="button" class="segBtn" data-division="4" aria-pressed="false">1/16</button>
              <button type="button" class="segBtn" data-division="3" aria-pressed="false">Triplet</button>
            </div>
            <div class="segNote" id="segNote" aria-live="polite"></div>

            <div class="ghostModeRow">
              <div class="label">GHOST BEAT</div>
              <label class="toggleSwitch">
                <input type="checkbox" id="ghostModeToggle" aria-label="GHOST BEAT é–‹é—œ" />
                <span class="slider"></span>
              </label>
            </div>

            <div class="progressiveModeRow">
              <div class="label">Step</div>
              <label class="toggleSwitch">
                <input type="checkbox" id="progressiveModeToggle" aria-label="Step è‡ªå‹•æé€Ÿ é–‹é—œ" />
                <span class="slider"></span>
              </label>
            </div>

            <div class="grooveSeg" role="group" aria-label="æ›²é¢¨é¢¨æ ¼é è¨­">
              <button type="button" class="grooveBtn" data-groove="standard" aria-pressed="true">Standard</button>
              <button type="button" class="grooveBtn" data-groove="boombap" aria-pressed="false">Boom Bap</button>
              <button type="button" class="grooveBtn" data-groove="trap" aria-pressed="false">Trap</button>
              <button type="button" class="grooveBtn" data-groove="reggae" aria-pressed="false">Reggae</button>
            </div>
          </div>
        </section>

      </div>

      <div class="controlsRow">
        <button class="bigButton" id="btnPlay" type="button" aria-label="é–‹å§‹æˆ–åœæ­¢">
          <span id="playLabel">START</span>
          <span class="small" id="playSub">é»æ“Šä»¥è§£é–éŸ³è¨Š</span>
        </button>
      </div>

      <div class="footer">
        PWAï¼šåœ¨ Safari åˆ†äº«é¸å–®é¸ã€ŒåŠ å…¥ä¸»ç•«é¢ã€å³å¯é›¢ç·šä½¿ç”¨ã€‚
      </div>
    </div>

    <div class="toast" id="toast" role="status" aria-live="polite"></div>
    
    <!-- Calendar Modal -->
    <div class="calendarModal" id="calendarModal">
      <div class="calendarContent">
        <div class="calendarHeader">
          <h2>è¨“ç·´æ—¥æ›†</h2>
          <button type="button" class="calendarCloseBtn" id="calendarCloseBtn">é—œé–‰</button>
        </div>
        <div class="calendarBody">
          <!-- Daily Goal Progress in Calendar -->
          <div class="calendarDailyGoal" id="calendarDailyGoal">
            <div class="calendarDailyGoalHeader">
              <div class="calendarDailyGoalTitle">ä»Šæ—¥ç›®æ¨™é€²åº¦ï¼ˆ20åˆ†é˜ï¼‰</div>
            </div>
            <div class="dailyGoalProgressInfo" id="calendarDailyGoalProgressInfo">
              <span id="calendarDailyGoalProgressText">0 / 20 åˆ†é˜</span>
              <span id="calendarDailyGoalProgressPercent">0%</span>
            </div>
            <div class="dailyGoalProgressBar">
              <div class="dailyGoalProgressFill" id="calendarDailyGoalProgressFill"></div>
            </div>
          </div>
          <div class="calendarStats">
            <div class="calendarStatsTitle">çµ±è¨ˆ</div>
            <div class="calendarStatsGrid" id="calendarStats">
              <!-- Stats will be populated by JS -->
            </div>
          </div>
          <div class="calendarNav">
            <button type="button" class="calendarNavBtn" id="calendarPrevMonth">â€¹</button>
            <div class="calendarMonthYear" id="calendarMonthYear"></div>
            <button type="button" class="calendarNavBtn" id="calendarNextMonth">â€º</button>
            <button type="button" class="calendarTodayBtn" id="calendarTodayBtn">å›åˆ°ä»Šå¤©</button>
          </div>
          <div class="calendarGrid" id="calendarGrid">
            <!-- Calendar will be populated by JS -->
          </div>
          <div class="calendarDayDetail" id="calendarDayDetail" style="display: none;">
            <!-- Day detail will be populated by JS -->
          </div>
        </div>
      </div>
    </div>

    <script>
      (() => {
        "use strict";

        // ===== Utilities =====
        const clamp = (v, min, max) => Math.min(max, Math.max(min, v));

        function showToast(msg, ms = 1400) {
          const el = document.getElementById("toast");
          el.textContent = msg;
          el.classList.add("show");
          window.clearTimeout(showToast._t);
          showToast._t = window.setTimeout(() => el.classList.remove("show"), ms);
        }

        function formatDivision(div) {
          if (div === 1) return "1/4";
          if (div === 2) return "1/8";
          if (div === 4) return "1/16";
          if (div === 3) return "Triplet";
          return String(div);
        }

        const GROOVE_PRESETS = {
          standard: {
            label: "Standard",
            division: 1,
            // accent per beat (0-based): 2 = å¼·, 1 = ä¸­, 0 = å¼±
            pattern4: [2, 1, 1, 1],
          },
          boombap: {
            label: "Boom Bap",
            division: 2, // 1/8 éŸ³ç¬¦
            pattern4: [1, 2, 1, 2], // å¼·èª¿ç¬¬ 2 & 4 æ‹ï¼ˆæ°¸é é–å®šï¼‰
          },
          trap: {
            label: "Trap",
            division: 3, // Tripletï¼ˆä¸‰é€£éŸ³ï¼‰
            pattern4: [2, 1, 2, 1], // ç¨å¾®å¼·èª¿æ¯å°ç¯€é–‹é ­èˆ‡ç¬¬ä¸‰æ‹
          },
          reggae: {
            label: "Reggae",
            division: 2, // 1/8 éŸ³ç¬¦
            pattern4: [1, 2, 1, 2], // ç¬¬ 2ã€4 æ‹å¼·éŸ³ï¼ˆé‡éŸ³ï¼‰ï¼Œæ¨¡æ“¬é›·é¬¼/çˆµå£«çš„å¾ŒåŠæ‹å¼·èª¿æ„Ÿ
          },
        };

        // ===== Cell Modes =====
        const CELL_MODES = {
          quarter: { label: "1/4", div: 1, step: 48 },      // æ¯æ‹ 1 å€‹é»
          eighth: { label: "1/8", div: 2, step: 24 },       // æ¯æ‹ 2 å€‹é»
          sixteenth: { label: "1/16", div: 4, step: 12 },  // æ¯æ‹ 4 å€‹é»
          triplet: { label: "Triplet", div: 3, step: 16 },   // æ¯æ‹ 3 å€‹é»ï¼ˆä¸‰é€£éŸ³ï¼‰
        };
        const CELL_MODE_ORDER = ["quarter", "eighth", "sixteenth", "triplet"];

        // ===== Web Audio Metronome (Lookahead Scheduler) =====
        class MetronomeEngine {
          constructor() {
            this.audio = null;
            this.master = null;
            this.isPlaying = false;

            this.bpm = 92;
            this.beatsPerBar = 4;
            this.division = 1; // subdivisions per beat (1,2,3,4) - legacy, kept for compatibility
            this.pendingDivision = null;

            // Cell Editor: æ¯ä¸€æ‹çš„ç´°åˆ†æ¨¡å¼ (0-3 for 4 beats)
            this.cellModes = ["quarter", "quarter", "quarter", "quarter"]; // é è¨­å…¨éƒ¨ 1/4

            this.nextTickTime = 0;
            this.microIndex = 0; // 1/48 ç¶²æ ¼ç´¢å¼•
            this.lastTickTime = 0;

            this.microDiv = 48; // æœ€å°ç´°åˆ†å–®ä½ï¼ˆ1/48ï¼‰
            this.scheduleAheadTime = 0.16;
            this.schedulerIntervalMs = 25;
            this._timer = null;

            this.gainDown = 0.85;
            this.gainBeat = 0.65;
            this.gainSub = 0.40;
            
            // Trap Snare éŸ³è‰²ç·©å­˜ï¼ˆTR-808 Clap/Snare æ··åˆéŸ³ï¼‰
            this._trapSnareBuffer = null;
            
            // Reggae åæ‹éŸ³è‰²ç·©å­˜
            this._reggaeOffbeatBuffer = null;

            // UI sync hint
            this._lastScheduledInfo = { bar: 1, beat: 1, sub: 1, isDownbeat: true, isBeatBoundary: true };

            this.grooveName = "standard";
            
            // Boom Bap éŸ³è‰²ç·©å­˜
            this._boombapBuffers = {};

            // Ghost Mode: éš¨æ©Ÿç©ºæ‹è¨“ç·´
            this.ghostMode = false;
            this.ghostProbability = 0.15; // 15% æ©Ÿç‡ç©ºæ‹
            this._ghostState = {
              isGhosting: false,
              ghostUntilMicro: -1, // ç©ºæ‹åˆ°å“ªå€‹ microIndex
            };

            // Swing: å¶æ•¸æ‹å»¶é²ï¼ˆ0-100%ï¼Œ50% = ç„¡ swingï¼Œ66% = ç¶“å…¸ swingï¼‰
            this.swing = 0; // 0-100

            // Progressive Training Mode: æ¼¸é€²å¼ç·´ç¿’æ¨¡å¼
            this.progressiveMode = false;
            this.initialBpm = 92; // è¨˜éŒ„é–‹å§‹æ™‚çš„ BPM
            this.progressiveBarsPerStep = 4; // æ¯ 4 å°ç¯€æé€Ÿä¸€æ¬¡
            this.progressiveBpmIncrement = 2; // æ¯æ¬¡å¢åŠ  2 BPM
            this.progressiveMaxBpm = 200; // æœ€å¤§ BPM é™åˆ¶
            this._lastProgressiveBar = 0;
            this._shouldFlashBpm = false; // è§¸ç™¼è¦–è¦ºé–ƒçˆ
            
            // è®­ç»ƒæ•°æ®è®°å½•ï¼šå½“å‰ä¼šè¯
            this._currentSession = null;
            this._sessionStartTime = null;
          }

          async ensureAudioUnlocked() {
            if (!this.audio) {
              const AC = window.AudioContext || window.webkitAudioContext;
              this.audio = new AC({ latencyHint: "interactive" });
              this.master = this.audio.createGain();
              this.master.gain.value = 0.9;
              this.master.connect(this.audio.destination);
            }
            if (this.audio.state !== "running") {
              await this.audio.resume();
            }
          }

          setBpm(bpm) {
            this.bpm = clamp(Math.round(bpm), 40, 240);
          }

          requestDivision(div) {
            // Apply on next beat boundary for stable feel
            if (div === this.division) return;
            this.pendingDivision = div;
          }

          setGroove(name) {
            if (!GROOVE_PRESETS[name]) return;
            this.grooveName = name;
          }

          setGhostMode(enabled) {
            this.ghostMode = enabled;
            if (!enabled) {
              // é—œé–‰æ™‚é‡ç½® ghost state
              this._ghostState.isGhosting = false;
              this._ghostState.ghostUntilMicro = -1;
            }
          }

          setSwing(percent) {
            this.swing = clamp(Math.round(percent), 0, 100);
          }

          setProgressiveMode(enabled) {
            this.progressiveMode = enabled;
            if (enabled) {
              // å•Ÿç”¨æ™‚è¨˜éŒ„ç•¶å‰ BPM ä½œç‚ºèµ·å§‹é»
              this.initialBpm = this.bpm;
              this._lastProgressiveBar = 0;
            } else {
              // é—œé–‰æ™‚æ¢å¾©åˆ°åˆå§‹ BPM
              this.bpm = this.initialBpm;
            }
          }


          // è¨ˆç®— swing å»¶é²ï¼ˆé‡å°å¶æ•¸æ‹ï¼‰
          _getSwingDelay(microInBar) {
            if (this.swing === 0 || this.swing === 50) return 0; // ç„¡ swing
            
            const beatIdx = Math.floor(microInBar / this.microDiv); // 0-3
            const isEvenBeat = (beatIdx === 1 || beatIdx === 3); // ç¬¬ 2ã€4 æ‹ï¼ˆ0-based: 1, 3ï¼‰
            
            if (!isEvenBeat) return 0; // å¥‡æ•¸æ‹ä¸å»¶é²
            
            // Swing è¨ˆç®—ï¼šå¾ 50% é–‹å§‹ï¼Œæ¯å¢åŠ  1% å»¶é²ç´„ 0.4% çš„æ‹é•·
            // 66% swing = ç¶“å…¸ triplet swingï¼ˆå»¶é²ç´„ 6.4%ï¼‰
            const swingOffset = (this.swing - 50) / 50; // -1 åˆ° 1
            const secPerBeat = 60 / this.bpm;
            const delay = swingOffset * secPerBeat * 0.16; // æœ€å¤§å»¶é²ç´„ 16% æ‹é•·
            
            return Math.max(0, delay);
          }

          // è¨ˆç®— Boom Bap é¢¨æ ¼çš„ swing å»¶é²ï¼ˆé‡å° 1/8 éŸ³ç¬¦çš„åæ‹ï¼‰
          _getBoomBapSwingDelay(posInBeat, cellMode) {
            // åªåœ¨ 1/8 éŸ³ç¬¦æ¨¡å¼ä¸‹æ‡‰ç”¨ 58% swing
            if (cellMode !== "eighth") return 0;
            
            // 1/8 éŸ³ç¬¦ï¼šposInBeat = 0 (on-beat), posInBeat = 24 (off-beat '&')
            // åªåœ¨ off-beat æ™‚æ‡‰ç”¨å»¶é²
            if (posInBeat !== 24) return 0;
            
            // 58% swing: è¨ˆç®—å»¶é²
            // 58% = (58 - 50) / 50 = 0.16 çš„ swing offset
            const swingOffset = (58 - 50) / 50; // 0.16
            const secPerBeat = 60 / this.bpm;
            const delay = swingOffset * secPerBeat * 0.16; // ç´„ 3.2% æ‹é•·çš„å»¶é²
            
            return Math.max(0, delay);
          }

          // æª¢æŸ¥æ˜¯å¦æ˜¯ 1/16 éŸ³ç¬¦çš„ 'e' æˆ– 'a' ä½ç½®ï¼ˆghost notesï¼‰
          _isSixteenthGhostNote(posInBeat) {
            // 1/16 éŸ³ç¬¦ï¼šposInBeat = 0 ('1'), 12 ('e'), 24 ('&'), 36 ('a')
            // 'e' å’Œ 'a' æ˜¯ ghost notes
            return posInBeat === 12 || posInBeat === 36;
          }

          // Cell Editor: è¨­å®šæ•´å°ç¯€ç‚ºåŒä¸€æ¨¡å¼ï¼ˆæ¨¡æ¿åŠŸèƒ½ï¼‰
          setAllCellsToMode(mode) {
            if (!CELL_MODES[mode]) return;
            for (let i = 0; i < this.beatsPerBar; i++) {
              this.cellModes[i] = mode;
            }
          }

          // Cell Editor: åˆ‡æ›å–®ä¸€æ‹çš„æ¨¡å¼
          cycleCellMode(beatIndex) {
            if (beatIndex < 0 || beatIndex >= this.beatsPerBar) return;
            const current = this.cellModes[beatIndex];
            const idx = CELL_MODE_ORDER.indexOf(current);
            const nextIdx = (idx + 1) % CELL_MODE_ORDER.length;
            this.cellModes[beatIndex] = CELL_MODE_ORDER[nextIdx];
            return this.cellModes[beatIndex];
          }

          // å–å¾—æŸä¸€æ‹çš„æ¨¡å¼
          getCellMode(beatIndex) {
            return this.cellModes[beatIndex] || "quarter";
          }

          // æª¢æŸ¥åœ¨ 1/48 ç¶²æ ¼ä¸­ï¼ŒæŸå€‹ä½ç½®æ˜¯å¦æ‡‰è©²æ‰“é»
          _shouldTickAtMicro(microInBar) {
            const beatIdx = Math.floor(microInBar / this.microDiv); // 0-3
            const posInBeat = microInBar % this.microDiv; // 0-47
            const mode = this.getCellMode(beatIdx);
            const cellDef = CELL_MODES[mode];
            if (!cellDef) return false;
            return posInBeat % cellDef.step === 0;
          }

          _microIntervalSec() {
            const secPerBeat = 60 / this.bpm;
            return secPerBeat / this.microDiv;
          }

          _tickIntervalSec(currentDivision = this.division) {
            const secPerBeat = 60 / this.bpm;
            return secPerBeat / currentDivision;
          }

          _ticksPerBar(currentDivision = this.division) {
            return this.beatsPerBar * currentDivision;
          }

          // æª¢æŸ¥æ˜¯å¦æ˜¯ Reggae çš„åæ‹ä½ç½®ï¼ˆæ”¯æŒæ‰€æœ‰ç´°åˆ†ï¼‰
          _isReggaeOffbeat(cellMode, posInBeat) {
            if (cellMode === "quarter") {
              return false; // 1/4 æ²’æœ‰ç´°åˆ†ï¼Œæ²’æœ‰åæ‹
            } else if (cellMode === "eighth") {
              // 1/8: ç¬¬äºŒå€‹å…«åˆ†éŸ³ç¬¦ï¼ˆposInBeat === 24ï¼‰
              return posInBeat === 24;
            } else if (cellMode === "sixteenth") {
              // 1/16: ç¬¬äºŒã€å››å€‹åå…­åˆ†éŸ³ç¬¦ï¼ˆposInBeat === 12, 36ï¼‰
              return posInBeat === 12 || posInBeat === 36;
            } else if (cellMode === "triplet") {
              // Triplet: ç¬¬äºŒå€‹ä¸‰é€£éŸ³ï¼ˆposInBeat === 16ï¼‰
              return posInBeat === 16;
            }
            return false;
          }

          // ç”Ÿæˆ Reggae é¢¨æ ¼çš„åæ‹éŸ³è‰²ï¼ˆç”¨æ–¼ Reggae é¢¨æ ¼çš„åæ‹ï¼‰
          _createReggaeOffbeatSound() {
            if (this._reggaeOffbeatBuffer) return this._reggaeOffbeatBuffer;
            
            const sampleRate = this.audio.sampleRate;
            const duration = 0.10; // ç¨é•·ï¼Œæ›´æœ‰å½ˆæ€§
            const length = Math.floor(sampleRate * duration);
            const buffer = this.audio.createBuffer(1, length, sampleRate);
            const data = buffer.getChannelData(0);
            
            // Reggae åæ‹ç‰¹å¾µï¼š
            // 1. ä¸­é »æ­£å¼¦æ³¢ï¼ˆæ¨¡æ“¬å‰ä»–æˆ–éµç›¤çš„å½ˆæ’¥è²ï¼‰
            // 2. è¼•å¾®çš„ç™½å™ªéŸ³ï¼ˆæ¨¡æ“¬æ‰“æ“Šæ„Ÿï¼‰
            // 3. è¼ƒæ…¢çš„è¡°æ¸›ï¼ˆæ›´æœ‰å½ˆæ€§ï¼‰
            
            for (let i = 0; i < length; i++) {
              const t = i / sampleRate;
              
              // ä¸­é »æ­£å¼¦æ³¢ï¼ˆç´„ 400-500Hzï¼Œæ¨¡æ“¬å‰ä»–å½ˆæ’¥ï¼‰
              let tone = 0;
              const fundamental = 450;
              const harmonics = [1, 1.5, 2]; // è«§æ³¢
              harmonics.forEach((harmonic, idx) => {
                const amp = idx === 0 ? 0.4 : 0.2 / idx;
                tone += Math.sin(2 * Math.PI * fundamental * harmonic * t) * amp;
              });
              
              // è¼•å¾®ç™½å™ªéŸ³ï¼ˆæ‰“æ“Šæ„Ÿï¼‰
              const noise = (Math.random() * 2 - 1) * 0.3;
              
              // åŒ…çµ¡ï¼šå¿«é€Ÿæ”»æ“Šï¼Œè¼ƒæ…¢è¡°æ¸›ï¼ˆæ›´æœ‰å½ˆæ€§ï¼‰
              let envelope = 1.0;
              if (t < 0.002) {
                envelope = t / 0.002;
              } else {
                envelope = Math.exp(-t / 0.04); // è¼ƒæ…¢çš„è¡°æ¸›
              }
              
              // æ··åˆéŸ³è‰²ï¼Œæ‡‰ç”¨åŒ…çµ¡
              data[i] = (tone * 0.7 + noise * 0.3) * envelope;
            }
            
            this._reggaeOffbeatBuffer = buffer;
            return buffer;
          }

          // ç”Ÿæˆ Boom Bap é¢¨æ ¼çš„é¼“è²éŸ³è‰²ï¼ˆç”¨æ–¼ Boom Bap é¢¨æ ¼ï¼‰
          _createBoomBapSound(type) {
            const cacheKey = `boombap_${type}`;
            if (this._boombapBuffers[cacheKey]) {
              return this._boombapBuffers[cacheKey];
            }
            
            const sampleRate = this.audio.sampleRate;
            let duration = 0.15;
            let buffer;
            let data;
            
            if (type === "kick") {
              // Kick: Deep, punchy kick using Sine wave with rapid pitch envelope decay
              // Add slight distortion/low-pass filter for "dusty" 90s vinyl sound
              duration = 0.25;
              const length = Math.floor(sampleRate * duration);
              buffer = this.audio.createBuffer(1, length, sampleRate);
              data = buffer.getChannelData(0);
              
              const startFreq = 60; // èµ·å§‹é »ç‡
              const endFreq = 30;  // çµæŸé »ç‡ï¼ˆå¿«é€ŸéŸ³é«˜è¡°æ¸›ï¼‰
              
              for (let i = 0; i < length; i++) {
                const t = i / sampleRate;
                
                // éŸ³é«˜åŒ…çµ¡ï¼šå¿«é€Ÿè¡°æ¸›ï¼ˆæ¨¡æ“¬ "thud" è²ï¼‰
                const pitchEnv = startFreq + (endFreq - startFreq) * Math.exp(-t * 20);
                
                // æ­£å¼¦æ³¢
                let sample = Math.sin(2 * Math.PI * pitchEnv * t);
                
                // è¼•å¾®å¤±çœŸï¼ˆæ¨¡æ“¬é»‘è† å”±ç‰‡çš„ "dusty" æ„Ÿï¼‰
                sample = Math.tanh(sample * 1.2) * 0.85;
                
                // ä½é€šæ¿¾æ³¢æ•ˆæœï¼ˆæ¨¡æ“¬é»‘è† çš„æº«æš–æ„Ÿï¼‰
                // ç°¡å–®å¯¦ç¾ï¼šè¡°æ¸›é«˜é »æˆåˆ†
                const lowpassEnv = Math.exp(-t * 8);
                sample *= lowpassEnv;
                
                // åŒ…çµ¡ï¼šå¿«é€Ÿæ”»æ“Šï¼Œä¸­ç­‰è¡°æ¸›
                let envelope = 1.0;
                if (t < 0.003) {
                  envelope = t / 0.003;
                } else {
                  envelope = Math.exp(-t * 6);
                }
                
                data[i] = sample * envelope * 0.9;
              }
            } else if (type === "snare") {
              // Snare: Dry, crisp snare using White Noise + short triangle wave body
              // Should sound tight, not reverb-heavy
              duration = 0.12;
              const length = Math.floor(sampleRate * duration);
              buffer = this.audio.createBuffer(1, length, sampleRate);
              data = buffer.getChannelData(0);
              
              for (let i = 0; i < length; i++) {
                const t = i / sampleRate;
                
                // ç™½å™ªéŸ³ï¼ˆä¸»è¦æˆåˆ†ï¼‰
                const noise = (Math.random() * 2 - 1) * 0.7;
                
                // çŸ­ä¸‰è§’æ³¢é«”ï¼ˆå¢åŠ ç·Šå¯¦æ„Ÿï¼‰
                const triangleFreq = 200;
                const trianglePhase = (t * triangleFreq) % 1;
                let triangle = trianglePhase < 0.5 
                  ? 4 * trianglePhase - 1 
                  : 3 - 4 * trianglePhase;
                triangle *= 0.3;
                
                // æ··åˆå™ªéŸ³å’Œä¸‰è§’æ³¢
                let sample = noise + triangle;
                
                // åŒ…çµ¡ï¼šæ¥µå¿«æ”»æ“Šï¼Œå¿«é€Ÿè¡°æ¸›ï¼ˆä¿æŒä¹¾ç‡¥ã€ç·Šå¯¦ï¼‰
                let envelope = 1.0;
                if (t < 0.001) {
                  envelope = t / 0.001;
                } else {
                  envelope = Math.exp(-t * 15); // å¿«é€Ÿè¡°æ¸›ï¼Œç„¡æ··éŸ¿
                }
                
                data[i] = sample * envelope * 0.85;
              }
            } else if (type === "hihat") {
              // Hi-Hat: Short, high-frequency metal sound using high-pass filtered noise
              duration = 0.06;
              const length = Math.floor(sampleRate * duration);
              buffer = this.audio.createBuffer(1, length, sampleRate);
              data = buffer.getChannelData(0);
              
              for (let i = 0; i < length; i++) {
                const t = i / sampleRate;
                
                // ç™½å™ªéŸ³
                const noise = (Math.random() * 2 - 1) * 0.6;
                
                // é«˜é€šæ¿¾æ³¢æ•ˆæœï¼ˆæ¨¡æ“¬é‡‘å±¬è²ï¼‰
                // ç°¡å–®å¯¦ç¾ï¼šå¢åŠ é«˜é »æˆåˆ†ï¼Œæ¸›å°‘ä½é »
                const highpassEnv = 1 - Math.exp(-t * 30); // å¿«é€Ÿå»é™¤ä½é »
                let sample = noise * highpassEnv;
                
                // é«˜é »æ­£å¼¦æ³¢ç–ŠåŠ ï¼ˆå¢åŠ é‡‘å±¬æ„Ÿï¼‰
                const metalFreq = 8000;
                const metalTone = Math.sin(2 * Math.PI * metalFreq * t) * 0.2;
                sample += metalTone;
                
                // åŒ…çµ¡ï¼šæ¥µå¿«æ”»æ“Šï¼Œå¿«é€Ÿè¡°æ¸›
                let envelope = 1.0;
                if (t < 0.0005) {
                  envelope = t / 0.0005;
                } else {
                  envelope = Math.exp(-t * 25);
                }
                
                data[i] = sample * envelope * 0.75;
              }
            }
            
            if (buffer) {
              this._boombapBuffers[cacheKey] = buffer;
              return buffer;
            }
            
            // Fallback
            const fallbackLength = Math.floor(sampleRate * 0.1);
            const fallbackBuffer = this.audio.createBuffer(1, fallbackLength, sampleRate);
            return fallbackBuffer;
          }
          
          // ç”Ÿæˆ TR-808 é¢¨æ ¼çš„ Clap/Snare æ··åˆéŸ³ï¼ˆç”¨æ–¼ Trap é¢¨æ ¼ï¼‰
          _createTrapSnareSound() {
            if (this._trapSnareBuffer) return this._trapSnareBuffer;
            
            const sampleRate = this.audio.sampleRate;
            const duration = 0.08; // æ›´çŸ­ã€æ›´è„†
            const length = Math.floor(sampleRate * duration);
            const buffer = this.audio.createBuffer(1, length, sampleRate);
            const data = buffer.getChannelData(0);
            
            // TR-808 Clap/Snare ç‰¹å¾µï¼š
            // 1. é«˜é »æ­£å¼¦æ³¢ï¼ˆæ¨¡æ“¬ Snare çš„éŸ¿å¼¦ï¼‰
            // 2. ç™½å™ªéŸ³ï¼ˆæ¨¡æ“¬ Clap çš„æ‹æ“Šè²ï¼‰
            // 3. å¿«é€Ÿè¡°æ¸›
            
            for (let i = 0; i < length; i++) {
              const t = i / sampleRate;
              
              // é«˜é »æ­£å¼¦æ³¢ï¼ˆSnare éŸ¿å¼¦ï¼Œç´„ 200-300Hz çš„è«§æ³¢ï¼‰
              let snare = 0;
              const snareFreq = 250;
              const snareHarmonics = [1, 2, 3, 4]; // å¤šå€‹è«§æ³¢
              snareHarmonics.forEach((harmonic, idx) => {
                const amp = 0.3 / (idx + 1); // è«§æ³¢è¡°æ¸›
                snare += Math.sin(2 * Math.PI * snareFreq * harmonic * t) * amp;
              });
              
              // ç™½å™ªéŸ³ï¼ˆClap æ‹æ“Šè²ï¼‰
              const noise = (Math.random() * 2 - 1) * 0.6;
              
              // åŒ…çµ¡ï¼šå¿«é€Ÿæ”»æ“Šï¼Œå¿«é€Ÿè¡°æ¸›
              let envelope = 1.0;
              if (t < 0.001) {
                // æ¥µå¿«æ”»æ“Š
                envelope = t / 0.001;
              } else {
                // å¿«é€ŸæŒ‡æ•¸è¡°æ¸›
                envelope = Math.exp(-t / 0.015);
              }
              
              // æ··åˆ Snare å’Œ Clapï¼Œæ‡‰ç”¨åŒ…çµ¡
              data[i] = (snare * 0.4 + noise * 0.6) * envelope;
            }
            
            this._trapSnareBuffer = buffer;
            return buffer;
          }

          _scheduleClick(time, { isDownbeat, isBeatBoundary, accentLevel, cellMode, posInBeat, beatIdx = 0 }) {
            const level = accentLevel ?? (isDownbeat ? 2 : isBeatBoundary ? 1 : 0);
            
            // Trap é¢¨æ ¼ï¼šä½¿ç”¨ TR-808 Clap/Snare æ··åˆéŸ³ï¼ˆåƒ…ç”¨æ–¼ Snareï¼Œå³ level >= 1ï¼‰
            if (this.grooveName === "trap" && level >= 1) {
              const buffer = this._createTrapSnareSound();
              const source = this.audio.createBufferSource();
              const gain = this.audio.createGain();
              
              source.buffer = buffer;
              const amp = level >= 2 ? this.gainDown : this.gainBeat;
              gain.gain.setValueAtTime(amp, time);
              
              source.connect(gain);
              gain.connect(this.master);
              
              source.start(time);
              source.stop(time + buffer.duration);
              return;
            }
            
            // Reggae é¢¨æ ¼ï¼šåæ‹ä½¿ç”¨ç‰¹æ®ŠéŸ³è‰²ï¼ˆlevel >= 2 ä¸”æ˜¯åæ‹ï¼‰
            if (this.grooveName === "reggae" && level >= 2 && !isBeatBoundary) {
              const buffer = this._createReggaeOffbeatSound();
              const source = this.audio.createBufferSource();
              const gain = this.audio.createGain();
              
              source.buffer = buffer;
              gain.gain.setValueAtTime(this.gainDown, time);
              
              source.connect(gain);
              gain.connect(this.master);
              
              source.start(time);
              source.stop(time + buffer.duration);
              return;
            }
            
            // Boom Bap é¢¨æ ¼ï¼šä½¿ç”¨ç‰¹æ®ŠéŸ³è‰²åˆæˆ
            if (this.grooveName === "boombap") {
              let drumType;
              let amp;
              
              // Boom Bap ç‰¹æ®ŠéŸ³é‡è™•ç†ï¼š
              // level 2: Heavy accent (Beat 2 & 4, hard snare) - ä½¿ç”¨ snare
              // level 1.8: Beat 1 (strong but slightly less) - ä½¿ç”¨ kickï¼ŒéŸ³é‡ç¨ä½
              // level 1.6: 1/8 off-beat (80% velocity, loud hi-hats) - ä½¿ç”¨ hihatï¼ŒéŸ³é‡è¼ƒé«˜
              // level 1: Medium accent (Beat 3) - ä½¿ç”¨ kick
              // level 0.35: Ghost notes ('e' and 'a' in 1/16) - ä½¿ç”¨ hihatï¼ŒéŸ³é‡å¾ˆä½
              // level 0: å…¶ä»–
              
              // 1/16 éŸ³ç¬¦ç‰¹æ®Šè™•ç†ï¼šon-beat ä½¿ç”¨ kick/snareï¼Œoff-beat ä½¿ç”¨ hi-hat
              if (cellMode === "sixteenth" && !isBeatBoundary) {
                // æ‰€æœ‰ 1/16 çš„ off-beat éƒ½ä½¿ç”¨ hi-hat
                drumType = "hihat";
                if (level >= 0.3 && this._isSixteenthGhostNote && this._isSixteenthGhostNote(posInBeat)) {
                  // 'e' and 'a': Ghost notes (30-40% velocity)
                  amp = this.gainSub * 0.35; // 35% of gainSub
                } else if (posInBeat === 24) {
                  // '&': Off-beat, medium volume
                  amp = this.gainSub * 0.6; // 60% of gainSub
                } else {
                  // å…¶ä»– off-beat: è¼ƒå°éŸ³é‡
                  amp = this.gainSub * 0.4;
                }
              } else if (level >= 2) {
                // Beat 2 & 4: Hard snare
                drumType = "snare";
                amp = this.gainBeat;
              } else if (level >= 1.8) {
                // Beat 1: Strong but slightly less than snare (ä½¿ç”¨ kickï¼ŒéŸ³é‡ç¨ä½)
                drumType = "kick";
                amp = this.gainDown * 0.9; // 90% of gainDown
              } else if (level >= 1.6) {
                // 1/8 off-beat: Loud hi-hats (80% velocity)
                drumType = "hihat";
                amp = this.gainBeat * 0.8; // 80% of gainBeat (éŸ¿äº®çš„ hi-hats)
              } else if (level >= 1) {
                // Beat 3: Medium accent (kick)
                drumType = "kick";
                amp = this.gainDown * 0.7; // 70% of gainDown
              } else if (level >= 0.3) {
                // Ghost notes ('e' and 'a' in 1/16): Very quiet (30-40% velocity)
                drumType = "hihat";
                amp = this.gainSub * 0.35; // 35% of gainSub (ghost note)
              } else {
                // å…¶ä»–ï¼šéœéŸ³æˆ–æ¥µå°éŸ³é‡
                drumType = "hihat";
                amp = this.gainSub * 0.1;
              }
              
              const buffer = this._createBoomBapSound(drumType);
              const source = this.audio.createBufferSource();
              const gain = this.audio.createGain();
              
              source.buffer = buffer;
              gain.gain.setValueAtTime(amp, time);
              
              source.connect(gain);
              gain.connect(this.master);
              
              source.start(time);
              source.stop(time + buffer.duration);
              return;
            }
            
            // ä½¿ç”¨é¼“çµ„éŸ³è‰²
            let drumType;
            let amp;
            
            if (level >= 2) {
              drumType = "kick";
              amp = this.gainDown;
            } else if (level === 1) {
              drumType = "snare";
              amp = this.gainBeat;
            } else {
              drumType = "hihat";
              amp = this.gainSub;
            }
            
            // ä½¿ç”¨æ¨™æº– oscillator clickï¼ˆé›»å­é«˜é »é»æ“Šï¼‰
            const osc = this.audio.createOscillator();
            const gain = this.audio.createGain();

            const dur = 0.030;
            const attack = 0.002;

            let freq = 1050;
            if (level >= 2) {
              freq = 2050;
            } else if (level === 1) {
              freq = 1500;
            }

            osc.type = "square";
            osc.frequency.setValueAtTime(freq, time);

            gain.gain.setValueAtTime(0.0001, time);
            gain.gain.exponentialRampToValueAtTime(Math.max(0.0001, amp), time + attack);
            gain.gain.exponentialRampToValueAtTime(0.0001, time + dur);

            osc.connect(gain);
            gain.connect(this.master);

            osc.start(time);
            osc.stop(time + dur + 0.01);
          }

          _schedulerStep(onScheduledTick) {
            if (!this.isPlaying) return;
            const audioNow = this.audio.currentTime;
            const limit = audioNow + this.scheduleAheadTime;
            const microInterval = this._microIntervalSec();
            const microsPerBar = this.beatsPerBar * this.microDiv; // 4 * 48 = 192

            while (this.nextTickTime < limit) {
              const microInBar = this.microIndex % microsPerBar;
              const beatIdx = Math.floor(microInBar / this.microDiv); // 0-3
              const posInBeat = microInBar % this.microDiv; // 0-47

              // æª¢æŸ¥é€™å€‹ micro ä½ç½®æ˜¯å¦æ‡‰è©²æ‰“é»ï¼ˆæ ¹æ“š cell modeï¼‰
              if (this._shouldTickAtMicro(microInBar)) {
                const isDownbeat = microInBar === 0;
                const isBeatBoundary = posInBeat === 0;

                // Ghost Mode: éš¨æ©Ÿç©ºæ‹é‚è¼¯
                let shouldGhost = false;
                if (this.ghostMode) {
                  // å¦‚æœç•¶å‰åœ¨ ghost ç‹€æ…‹ä¸­ï¼Œæª¢æŸ¥æ˜¯å¦æ‡‰è©²çµæŸ
                  if (this._ghostState.isGhosting) {
                    if (this.microIndex > this._ghostState.ghostUntilMicro) {
                      this._ghostState.isGhosting = false;
                      this._ghostState.ghostUntilMicro = -1;
                    } else {
                      shouldGhost = true; // ç¹¼çºŒ ghost
                    }
                  } else {
                    // éš¨æ©Ÿæ±ºå®šæ˜¯å¦é–‹å§‹ ghostï¼ˆåªåœ¨æ‹é»æ™‚æ±ºå®šï¼Œé¿å…éæ–¼é »ç¹ï¼‰
                    if (isBeatBoundary && Math.random() < this.ghostProbability) {
                      // ç©ºæ‹æŒçºŒ 1-2 æ‹ï¼ˆéš¨æ©Ÿï¼‰
                      const ghostBeats = Math.random() < 0.5 ? 1 : 2;
                      const ghostMicros = ghostBeats * this.microDiv;
                      this._ghostState.isGhosting = true;
                      this._ghostState.ghostUntilMicro = this.microIndex + ghostMicros;
                      shouldGhost = true;
                    }
                  }
                }

                // åªæœ‰åœ¨é ghost ç‹€æ…‹æ™‚æ‰æ’­æ”¾è²éŸ³
                if (!shouldGhost) {
                  // Groove accent: æ ¹æ“šé¢¨æ ¼æ±ºå®šé‡éŸ³
                  let accentLevel = 0;
                  const preset = GROOVE_PRESETS[this.grooveName] || GROOVE_PRESETS.standard;
                  const pattern = preset.pattern4 || GROOVE_PRESETS.standard.pattern4;
                  
                  if (isBeatBoundary) {
                    // æ‹é»ï¼ˆon-beatï¼‰ï¼šä½¿ç”¨ pattern çš„é‡éŸ³ç´šåˆ¥
                    if (this.grooveName === "boombap") {
                      // Boom Bap ç‰¹æ®Šè™•ç†ï¼šQuarter Notes
                      // Beat 2 & 4: Heavy accents (level 2, simulating hard snare)
                      // Beat 1: Strong but slightly less than snare (level 1.8, ä½¿ç”¨ 2 ä½†éŸ³é‡ç¨ä½)
                      // Beat 3: Medium accent (level 1)
                      const beatAccent = pattern[beatIdx % pattern.length] ?? 1;
                      if (beatIdx === 0) {
                        // Beat 1: Strong but slightly less than snare
                        accentLevel = 1.8; // ä½¿ç”¨ 1.8 è¡¨ç¤ºå¼·ä½†ç•¥å°æ–¼ level 2
                      } else if (beatIdx === 1 || beatIdx === 3) {
                        // Beat 2 & 4: Heavy accents (hard snare)
                        accentLevel = 2;
                      } else {
                        // Beat 3: Medium accent
                        accentLevel = 1;
                      }
                    } else if (this.grooveName === "reggae") {
                      // Reggae ç‰¹æ®Šè™•ç†ï¼šé‡éŸ³åœ¨ off-beatï¼Œæ‰€ä»¥ on-beat é™ä½é‡éŸ³
                      const beatAccent = pattern[beatIdx % pattern.length] ?? 1;
                      if (beatAccent >= 2) {
                        accentLevel = 1; // ç¬¬ 2ã€4 æ‹çš„ on-beat é™ç‚ºä¸­ç­‰é‡éŸ³ï¼ˆé‡éŸ³åœ¨ off-beatï¼‰
                      } else {
                        accentLevel = beatAccent; // å…¶ä»–æ‹ä¿æŒåŸæ¨£
                      }
                    } else {
                      accentLevel = pattern[beatIdx % pattern.length] ?? 1;
                    }
                  } else {
                    // ç´°åˆ†é»ï¼ˆoff-beat æˆ–å…¶ä»–ç´°åˆ†ï¼‰
                    const cellMode = this.getCellMode(beatIdx);
                    
                    if (this.grooveName === "boombap") {
                      // Boom Bap ç‰¹æ®Šè™•ç†
                      if (cellMode === "eighth") {
                        // Eighth Notes: CRITICAL - Apply 58% Swing/Shuffle
                        // Off-beat ('&') should have velocity ~80% (loud hi-hats)
                        if (posInBeat === 24) {
                          // Off-beat: velocity 80% (level 1.6)
                          accentLevel = 1.6;
                        } else {
                          // On-beat: ä½¿ç”¨æ‹é»çš„é‡éŸ³
                          accentLevel = 0;
                        }
                      } else if (cellMode === "sixteenth") {
                        // Sixteenth Notes: 'Funky Drummer' feel
                        // 'e' and 'a' subdivisions very quiet (Velocity 30-40) as ghost notes
                        if (this._isSixteenthGhostNote(posInBeat)) {
                          // 'e' and 'a': Ghost notes (level 0.3-0.4)
                          accentLevel = 0.35;
                        } else if (posInBeat === 24) {
                          // '&': Off-beat, medium volume
                          accentLevel = 1;
                        } else {
                          // On-beat: ä½¿ç”¨æ‹é»çš„é‡éŸ³
                          accentLevel = 0;
                        }
                      } else {
                        // Quarter Notes: å·²åœ¨ isBeatBoundary è™•ç†
                        accentLevel = 0;
                      }
                    } else if (this.grooveName === "reggae") {
                      // Reggae ç‰¹æ®Šè™•ç†ï¼šç¬¬ 2ã€4 æ‹çš„åæ‹ï¼ˆoff-beatï¼‰æœ‰å¼·é‡éŸ³
                      // æ¨¡æ“¬é›·é¬¼/çˆµå£«çš„å¾ŒåŠæ‹å¼·èª¿æ„Ÿ
                      // æ”¯æŒæ‰€æœ‰ç´°åˆ†ï¼š1/8, 1/16, triplet
                      if (this._isReggaeOffbeat(cellMode, posInBeat)) {
                        const beatAccent = pattern[beatIdx % pattern.length] ?? 1;
                        // å¦‚æœæ˜¯ç¬¬äºŒæ‹æˆ–ç¬¬å››æ‹ï¼ˆé‡éŸ³æ‹ï¼‰ï¼Œoff-beat æœ‰å¼·é‡éŸ³
                        if (beatAccent >= 2) {
                          accentLevel = 2; // ç¬¬ 2ã€4 æ‹çš„ off-beat æ˜¯å¼·é‡éŸ³ï¼ˆå¾ŒåŠæ‹å¼·èª¿ï¼‰
                        } else {
                          accentLevel = 0; // å…¶ä»–æ‹çš„ off-beat ç„¡é‡éŸ³
                        }
                      } else {
                        accentLevel = 0; // å…¶ä»–ç´°åˆ†é»ç„¡é‡éŸ³
                      }
                    } else {
                      // å…¶ä»–é¢¨æ ¼ï¼šç´°åˆ†é»é€šå¸¸ç„¡é‡éŸ³æˆ–å¼±é‡éŸ³
                      accentLevel = 0;
                    }
                  }

                  // Swing: è¨ˆç®—å»¶é²
                  let swingDelay = 0;
                  if (this.grooveName === "boombap") {
                    // Boom Bap: å° 1/8 éŸ³ç¬¦æ‡‰ç”¨ç‰¹æ®Šçš„ 58% swing
                    const cellMode = this.getCellMode(beatIdx);
                    swingDelay = this._getBoomBapSwingDelay(posInBeat, cellMode);
                    // å¦‚æœæ²’æœ‰æ‡‰ç”¨ Boom Bap swingï¼Œä½¿ç”¨é€šç”¨ swing
                    if (swingDelay === 0) {
                      swingDelay = this._getSwingDelay(microInBar);
                    }
                  } else {
                    swingDelay = this._getSwingDelay(microInBar);
                  }
                  const scheduledTime = this.nextTickTime + swingDelay;

                  // ç²å–ç•¶å‰çš„ cell mode ç”¨æ–¼éŸ³è‰²åˆ¤æ–·
                  const cellModeForClick = this.getCellMode(beatIdx);
                  
                  this._scheduleClick(scheduledTime, {
                    isDownbeat,
                    isBeatBoundary,
                    accentLevel,
                    cellMode: cellModeForClick,
                    posInBeat,
                    beatIdx,
                  });
                }

                this.lastTickTime = this.nextTickTime;

                // è¨ˆç®— sub è³‡è¨Šï¼ˆç”¨æ–¼ UI é¡¯ç¤ºï¼‰
                const cellMode = this.getCellMode(beatIdx);
                const cellDef = CELL_MODES[cellMode];
                const sub = Math.floor(posInBeat / cellDef.step) + 1;
                const bar = Math.floor(this.microIndex / microsPerBar) + 1;

                // Progressive Training Mode: æª¢æŸ¥æ˜¯å¦éœ€è¦æé€Ÿ
                if (this.progressiveMode && isDownbeat && bar > this._lastProgressiveBar) {
                  const barsSinceLastStep = bar - this._lastProgressiveBar;
                  if (barsSinceLastStep >= this.progressiveBarsPerStep) {
                    const newBpm = Math.min(
                      this.bpm + this.progressiveBpmIncrement,
                      this.progressiveMaxBpm
                    );
                    if (newBpm > this.bpm) {
                      this.bpm = newBpm;
                      this._shouldFlashBpm = true; // è§¸ç™¼è¦–è¦ºé–ƒçˆ
                      this._lastProgressiveBar = bar;
                    }
                  }
                }

                // è¨ˆç®—ç•¶å‰é‡éŸ³ç´šåˆ¥ï¼ˆç”¨æ–¼ UI é¡è‰²å›é¥‹ï¼‰
                let currentAccentLevel = 0;
                if (!shouldGhost) {
                  const preset = GROOVE_PRESETS[this.grooveName] || GROOVE_PRESETS.standard;
                  const pattern = preset.pattern4 || GROOVE_PRESETS.standard.pattern4;
                  
                  if (isBeatBoundary) {
                    // æ‹é»ï¼ˆon-beatï¼‰ï¼šä½¿ç”¨ pattern çš„é‡éŸ³ç´šåˆ¥
                    if (this.grooveName === "boombap") {
                      // Boom Bap ç‰¹æ®Šè™•ç†ï¼šQuarter Notes
                      // Beat 2 & 4: Heavy accents (level 2, simulating hard snare)
                      // Beat 1: Strong but slightly less than snare (level 1.8)
                      // Beat 3: Medium accent (level 1)
                      if (beatIdx === 0) {
                        currentAccentLevel = 1.8; // Beat 1: Strong but slightly less
                      } else if (beatIdx === 1 || beatIdx === 3) {
                        currentAccentLevel = 2; // Beat 2 & 4: Heavy accents
                      } else {
                        currentAccentLevel = 1; // Beat 3: Medium accent
                      }
                    } else if (this.grooveName === "reggae") {
                      // Reggae ç‰¹æ®Šè™•ç†ï¼šé‡éŸ³åœ¨ off-beatï¼Œæ‰€ä»¥ on-beat é™ä½é‡éŸ³
                      const beatAccent = pattern[beatIdx % pattern.length] ?? 1;
                      if (beatAccent >= 2) {
                        currentAccentLevel = 1; // ç¬¬ 2ã€4 æ‹çš„ on-beat é™ç‚ºä¸­ç­‰é‡éŸ³ï¼ˆé‡éŸ³åœ¨ off-beatï¼‰
                      } else {
                        currentAccentLevel = beatAccent; // å…¶ä»–æ‹ä¿æŒåŸæ¨£
                      }
                    } else {
                      currentAccentLevel = pattern[beatIdx % pattern.length] ?? 1;
                    }
                  } else {
                    // ç´°åˆ†é»ï¼ˆoff-beat æˆ–å…¶ä»–ç´°åˆ†ï¼‰
                    const cellMode = this.getCellMode(beatIdx);
                    
                    if (this.grooveName === "boombap") {
                      // Boom Bap ç‰¹æ®Šè™•ç†
                      if (cellMode === "eighth") {
                        // Eighth Notes: Off-beat ('&') should have velocity ~80% (loud hi-hats)
                        if (posInBeat === 24) {
                          currentAccentLevel = 1.6; // Off-beat: 80% velocity
                        } else {
                          currentAccentLevel = 0; // On-beat: å·²åœ¨ isBeatBoundary è™•ç†
                        }
                      } else if (cellMode === "sixteenth") {
                        // Sixteenth Notes: 'Funky Drummer' feel
                        // 'e' and 'a' subdivisions very quiet (Velocity 30-40) as ghost notes
                        if (this._isSixteenthGhostNote(posInBeat)) {
                          currentAccentLevel = 0.35; // Ghost notes
                        } else if (posInBeat === 24) {
                          currentAccentLevel = 1; // Off-beat: Medium volume
                        } else {
                          currentAccentLevel = 0; // On-beat: å·²åœ¨ isBeatBoundary è™•ç†
                        }
                      } else {
                        // Quarter Notes: å·²åœ¨ isBeatBoundary è™•ç†
                        currentAccentLevel = 0;
                      }
                    } else if (this.grooveName === "reggae") {
                      // Reggae ç‰¹æ®Šè™•ç†ï¼šç¬¬ 2ã€4 æ‹çš„åæ‹ï¼ˆoff-beatï¼‰æœ‰å¼·é‡éŸ³
                      // æ¨¡æ“¬é›·é¬¼/çˆµå£«çš„å¾ŒåŠæ‹å¼·èª¿æ„Ÿ
                      // æ”¯æŒæ‰€æœ‰ç´°åˆ†ï¼š1/8, 1/16, triplet
                      if (this._isReggaeOffbeat(cellMode, posInBeat)) {
                        const beatAccent = pattern[beatIdx % pattern.length] ?? 1;
                        if (beatAccent >= 2) {
                          currentAccentLevel = 2; // ç¬¬ 2ã€4 æ‹çš„ off-beat æ˜¯å¼·é‡éŸ³
                        } else {
                          currentAccentLevel = 0; // å…¶ä»–æ‹çš„ off-beat ç„¡é‡éŸ³
                        }
                      } else {
                        currentAccentLevel = 0; // å…¶ä»–ç´°åˆ†é»ç„¡é‡éŸ³
                      }
                    } else {
                      // å…¶ä»–é¢¨æ ¼ï¼šç´°åˆ†é»é€šå¸¸ç„¡é‡éŸ³
                      currentAccentLevel = 0;
                    }
                  }
                }

                this._lastScheduledInfo = {
                  bar,
                  beat: beatIdx + 1,
                  sub,
                  isDownbeat,
                  isBeatBoundary,
                  cellMode,
                  isGhost: shouldGhost,
                  accentLevel: currentAccentLevel,
                };

                if (onScheduledTick) {
                  onScheduledTick({
                    time: this.nextTickTime,
                    microIndex: this.microIndex,
                    microInBar,
                    beatIdx,
                    posInBeat,
                    bar,
                    beat: beatIdx + 1,
                    sub,
                    isDownbeat,
                    isBeatBoundary,
                    cellMode,
                  });
                }
              }

              // ç„¡è«–æ˜¯å¦æœ‰æ‰“é»ï¼Œæ™‚é–“è»¸éƒ½è¦ç¹¼çºŒå‰é€²
              this.nextTickTime += microInterval;
              this.microIndex += 1;
            }
          }

          start(onScheduledTick) {
            if (!this.audio) throw new Error("Audio not ready");
            if (this.isPlaying) return;

            // Re-sync to current audio time to avoid drift after pause/background
            const audioNow = this.audio.currentTime;
            const warmup = 0.06;
            this.nextTickTime = audioNow + warmup;
            this.lastTickTime = audioNow;

            // Align microIndex to start at bar boundary for clearer training
            this.microIndex = 0;

            // Progressive Mode: é‡ç½®ç‹€æ…‹
            if (this.progressiveMode) {
              this.initialBpm = this.bpm;
              this._lastProgressiveBar = 0;
            }

            // å¼€å§‹è®°å½•è®­ç»ƒä¼šè¯
            this._startTrainingSession();

            this.isPlaying = true;
            const loop = () => {
              this._schedulerStep(onScheduledTick);
              if (!this.isPlaying) return;
              this._timer = window.setTimeout(loop, this.schedulerIntervalMs);
            };
            loop();
          }

          stop() {
            if (!this.isPlaying) return;
            this.isPlaying = false;
            if (this._timer) {
              window.clearTimeout(this._timer);
              this._timer = null;
            }
            
            // ç»“æŸå¹¶ä¿å­˜è®­ç»ƒä¼šè¯
            this._endTrainingSession();
          }
          
          _startTrainingSession() {
            this._sessionStartTime = Date.now();
            this._currentSession = {
              startTime: new Date().toISOString(),
              bpm: this.bpm,
              initialBpm: this.bpm,
              groove: this.grooveName,
              division: this.division,
              cellModes: [...this.cellModes],
              ghostMode: this.ghostMode,
              progressiveMode: this.progressiveMode,
              swing: this.swing,
            };
          }
          
          _endTrainingSession() {
            if (!this._currentSession || !this._sessionStartTime) return;
            
            const duration = Math.floor((Date.now() - this._sessionStartTime) / 1000);
            if (duration < 1) {
              // å°‘äº1ç§’ä¸ä¿å­˜
              this._currentSession = null;
              this._sessionStartTime = null;
              return;
            }
            
            const record = {
              ...this._currentSession,
              endTime: new Date().toISOString(),
              duration: duration,
              finalBpm: this.bpm,
            };
            
            // ä¿å­˜åˆ°æ—¥å†ç³»ç»Ÿ
            TrainingCalendar.saveSession(record);
            
            // æ¸…ç†ä¼šè¯çŠ¶æ€
            this._currentSession = null;
            this._sessionStartTime = null;
          }
        }

        // ===== Settings Persistence =====
        const SETTINGS_KEY = "rapMetronomeSettings";
        const TRAINING_CALENDAR_KEY = "rapMetronomeTrainingCalendar";
        const DAILY_GOAL_KEY = "rapMetronomeDailyGoal";
        
        // ===== Daily Goal System =====
        class DailyGoal {
          static GOAL_MINUTES = 20; // å›ºå®š20åˆ†é’Ÿ
          
          static getGoal() {
            return this.GOAL_MINUTES;
          }
          
          static getTodayProgress() {
            const todayData = TrainingCalendar.getDateData(new Date());
            if (!todayData || !todayData.totalDuration) {
              return { duration: 0, goal: this.GOAL_MINUTES * 60 };
            }
            return {
              duration: todayData.totalDuration, // ç§’
              goal: this.GOAL_MINUTES * 60, // è½¬æ¢ä¸ºç§’
            };
          }
          
          static getProgressPercent() {
            const { duration, goal } = this.getTodayProgress();
            if (goal === 0) return 0;
            return Math.min(100, Math.round((duration / goal) * 100));
          }
          
          // æ£€æŸ¥æŒ‡å®šæ—¥æœŸæ˜¯å¦è¾¾æˆç›®æ ‡ï¼ˆ20åˆ†é’Ÿ = 1200ç§’ï¼‰
          static isGoalAchieved(date) {
            const dayData = TrainingCalendar.getDateData(date);
            if (!dayData || !dayData.totalDuration) return false;
            return dayData.totalDuration >= 1200; // 20åˆ†é’Ÿ = 1200ç§’
          }
        }
        
        // ===== Training Calendar System =====
        class TrainingCalendar {
          // è·å–æ—¥æœŸé”®ï¼ˆYYYY-MM-DDæ ¼å¼ï¼‰
          static getDateKey(date = new Date()) {
            const d = date instanceof Date ? date : new Date(date);
            const year = d.getFullYear();
            const month = String(d.getMonth() + 1).padStart(2, '0');
            const day = String(d.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
          }
          
          // ä¿å­˜è®­ç»ƒä¼šè¯
          static saveSession(session) {
            try {
              const dateKey = this.getDateKey();
              const calendar = this.loadCalendar();
              
              if (!calendar[dateKey]) {
                calendar[dateKey] = {
                  date: dateKey,
                  sessions: [],
                  totalDuration: 0,
                  totalSessions: 0,
                };
              }
              
              calendar[dateKey].sessions.push(session);
              calendar[dateKey].totalDuration += session.duration || 0;
              calendar[dateKey].totalSessions = calendar[dateKey].sessions.length;
              
              // åªä¿ç•™æœ€è¿‘365å¤©çš„æ•°æ®
              const cutoffDate = new Date();
              cutoffDate.setDate(cutoffDate.getDate() - 365);
              const cutoffKey = this.getDateKey(cutoffDate);
              
              Object.keys(calendar).forEach(key => {
                if (key < cutoffKey) {
                  delete calendar[key];
                }
              });
              
              localStorage.setItem(TRAINING_CALENDAR_KEY, JSON.stringify(calendar));
              
              // è§¦å‘æ›´æ–°äº‹ä»¶
              window.dispatchEvent(new CustomEvent('trainingCalendarUpdated', { detail: { dateKey } }));
              
              return true;
            } catch (e) {
              console.warn("Failed to save training session:", e);
              return false;
            }
          }
          
          // åŠ è½½æ—¥å†æ•°æ®
          static loadCalendar() {
            try {
              const saved = localStorage.getItem(TRAINING_CALENDAR_KEY);
              return saved ? JSON.parse(saved) : {};
            } catch (e) {
              console.warn("Failed to load training calendar:", e);
              return {};
            }
          }
          
          // è·å–ç‰¹å®šæ—¥æœŸçš„æ•°æ®
          static getDateData(date) {
            const calendar = this.loadCalendar();
            const dateKey = date instanceof Date ? this.getDateKey(date) : date;
            return calendar[dateKey] || null;
          }
          
          // è·å–æœˆä»½çš„æ‰€æœ‰æ•°æ®
          static getMonthData(year, month) {
            const calendar = this.loadCalendar();
            const monthKey = `${year}-${String(month).padStart(2, '0')}`;
            const result = {};
            
            Object.keys(calendar).forEach(dateKey => {
              if (dateKey.startsWith(monthKey)) {
                result[dateKey] = calendar[dateKey];
              }
            });
            
            return result;
          }
          
          // è·å–ç»Ÿè®¡æ•°æ®
          static getStats() {
            const calendar = this.loadCalendar();
            let totalDuration = 0;
            let daysWithTraining = 0;
            
            Object.values(calendar).forEach(dayData => {
              totalDuration += dayData.totalDuration || 0;
              if (dayData.totalSessions > 0) {
                daysWithTraining++;
              }
            });
            
            return {
              totalDuration,
              daysWithTraining,
            };
          }
          
          // è·å–BPMèŒƒå›´ï¼ˆæ¯5 BPMä¸ºåŒºé—´ï¼‰
          static getBpmRange(bpm) {
            // å‘ä¸‹å–æ•´åˆ°5çš„å€æ•°
            const rounded = Math.floor(bpm / 5) * 5;
            const start = Math.max(40, rounded);
            const end = Math.min(240, start + 5);
            return { start, end };
          }
          
          // è·å–æŒ‰æ¯5 BPMåŒºé—´çš„ç»ƒä¹ æ—¶é•¿ç»Ÿè®¡
          static getBpmRangeStats() {
            const calendar = this.loadCalendar();
            const bpmRanges = {};
            
            // åˆå§‹åŒ–æ‰€æœ‰å¯èƒ½çš„BPMåŒºé—´ï¼ˆ40-240ï¼Œæ¯5ä¸ºä¸€ä¸ªåŒºé—´ï¼‰
            for (let bpm = 40; bpm < 240; bpm += 5) {
              const range = this.getBpmRange(bpm);
              const rangeKey = `${range.start}-${range.end}`;
              if (!bpmRanges[rangeKey]) {
                bpmRanges[rangeKey] = {
                  rangeKey: rangeKey,
                  start: range.start,
                  end: range.end,
                  duration: 0,
                };
              }
            }
            
            // ç»Ÿè®¡æ¯ä¸ªBPMåŒºé—´çš„ç»ƒä¹ æ—¶é•¿
            Object.values(calendar).forEach(dayData => {
              if (dayData.sessions && dayData.sessions.length > 0) {
                dayData.sessions.forEach(session => {
                  // è®¡ç®—å¹³å‡BPMï¼ˆå¦‚æœæ˜¯Progressive Modeï¼‰
                  const avgBpm = session.progressiveMode && session.finalBpm 
                    ? Math.round((session.bpm + session.finalBpm) / 2)
                    : session.bpm;
                  
                  const range = this.getBpmRange(avgBpm);
                  const rangeKey = `${range.start}-${range.end}`;
                  
                  if (bpmRanges[rangeKey]) {
                    bpmRanges[rangeKey].duration += session.duration || 0;
                  }
                });
              }
            });
            
            // åªè¿”å›æœ‰æ•°æ®çš„åŒºé—´ï¼ŒæŒ‰BPMæ’åº
            return Object.values(bpmRanges)
              .filter(range => range.duration > 0)
              .sort((a, b) => a.start - b.start);
          }
          
          // è·å–æ—¥æœŸæŒ‰BPMèŒƒå›´åˆ†ç»„çš„æ•°æ®
          static getDateDataByBpmRange(date) {
            const dayData = this.getDateData(date);
            if (!dayData || !dayData.sessions || dayData.sessions.length === 0) {
              return {};
            }
            
            const ranges = {};
            dayData.sessions.forEach(session => {
              // è®¡ç®—å¹³å‡BPMï¼ˆå¦‚æœæ˜¯Progressive Modeï¼‰
              const avgBpm = session.progressiveMode && session.finalBpm 
                ? Math.round((session.bpm + session.finalBpm) / 2)
                : session.bpm;
              
              const range = this.getBpmRange(avgBpm);
              const rangeKey = `${range.start}-${range.end}`;
              
              if (!ranges[rangeKey]) {
                ranges[rangeKey] = {
                  rangeKey: rangeKey,
                  start: range.start,
                  end: range.end,
                  duration: 0,
                  sessions: 0,
                };
              }
              
              ranges[rangeKey].duration += session.duration || 0;
              ranges[rangeKey].sessions += 1;
            });
            
            return ranges;
          }
        }
        
        function saveSettings() {
          try {
            const settings = {
              bpm: engine.bpm,
              grooveName: engine.grooveName,
              swing: engine.swing,
              ghostMode: engine.ghostMode,
              progressiveMode: engine.progressiveMode,
              cellModes: [...engine.cellModes],
              division: engine.division,
              version: "0.8.5",
            };
            localStorage.setItem(SETTINGS_KEY, JSON.stringify(settings));
          } catch (e) {
            console.warn("Failed to save settings:", e);
          }
        }
        
        function loadSettings() {
          try {
            const saved = localStorage.getItem(SETTINGS_KEY);
            if (!saved) return null;
            
            const settings = JSON.parse(saved);
            // é©—è­‰è¨­å®šæœ‰æ•ˆæ€§
            if (settings.bpm && settings.bpm >= 40 && settings.bpm <= 240) {
              engine.bpm = settings.bpm;
            }
            if (settings.grooveName && GROOVE_PRESETS[settings.grooveName]) {
              engine.grooveName = settings.grooveName;
            }
            if (settings.swing !== undefined && settings.swing >= 0 && settings.swing <= 100) {
              engine.swing = settings.swing;
            }
            if (settings.ghostMode !== undefined) {
              engine.ghostMode = settings.ghostMode;
            }
            if (settings.progressiveMode !== undefined) {
              engine.progressiveMode = settings.progressiveMode;
              if (settings.progressiveMode) {
                engine.initialBpm = settings.bpm || engine.bpm;
              }
            }
            if (settings.cellModes && Array.isArray(settings.cellModes) && settings.cellModes.length === 4) {
              // é©—è­‰æ¯å€‹cell modeæ˜¯å¦æœ‰æ•ˆ
              const validModes = settings.cellModes.filter(m => CELL_MODE_ORDER.includes(m));
              if (validModes.length === 4) {
                engine.cellModes = validModes;
              }
            }
            if (settings.division && [1, 2, 3, 4].includes(settings.division)) {
              engine.division = settings.division;
            }
            
            return settings;
          } catch (e) {
            console.warn("Failed to load settings:", e);
            return null;
          }
        }

        // ===== App State =====
        const engine = new MetronomeEngine();
        const state = {
          wasPlayingBeforeHide: false,
          ui: {
            hiTickIndex: -1,
            lastScheduledTick: null,
          },
        };

        // ===== DOM =====
        const bpmValue = document.getElementById("bpmValue");
        const btnPlay = document.getElementById("btnPlay");
        const playLabel = document.getElementById("playLabel");
        const playSub = document.getElementById("playSub");
        const bpmSlider = document.getElementById("bpmSlider");
        const swingSlider = document.getElementById("swingSlider");
        const swingValue = document.getElementById("swingValue");
        const segBtns = Array.from(document.querySelectorAll(".segBtn"));
        const segNote = document.getElementById("segNote");
        const grooveBtns = Array.from(document.querySelectorAll(".grooveBtn"));
        const ghostModeToggle = document.getElementById("ghostModeToggle");
        const progressiveModeToggle = document.getElementById("progressiveModeToggle");
        const statePill = document.getElementById("statePill");
        const stateText = document.getElementById("stateText");
        const timelineMeta = document.getElementById("timelineMeta");
        const bpmDrag = document.getElementById("bpmDrag");
        const tapTempoBtn = document.getElementById("tapTempoBtn");
        const calendarBtn = document.getElementById("calendarBtn");
        const calendarModal = document.getElementById("calendarModal");
        const calendarCloseBtn = document.getElementById("calendarCloseBtn");
        const calendarPrevMonth = document.getElementById("calendarPrevMonth");
        const calendarNextMonth = document.getElementById("calendarNextMonth");
        const calendarMonthYear = document.getElementById("calendarMonthYear");
        const calendarGrid = document.getElementById("calendarGrid");
        const calendarDayDetail = document.getElementById("calendarDayDetail");
        const calendarStats = document.getElementById("calendarStats");
        const dailyGoalCard = document.getElementById("dailyGoalCard");
        const dailyGoalProgressText = document.getElementById("dailyGoalProgressText");
        const dailyGoalProgressPercent = document.getElementById("dailyGoalProgressPercent");
        const dailyGoalProgressFill = document.getElementById("dailyGoalProgressFill");
        const calendarDailyGoal = document.getElementById("calendarDailyGoal");
        const calendarDailyGoalProgressText = document.getElementById("calendarDailyGoalProgressText");
        const calendarDailyGoalProgressPercent = document.getElementById("calendarDailyGoalProgressPercent");
        const calendarDailyGoalProgressFill = document.getElementById("calendarDailyGoalProgressFill");

        const canvas = document.getElementById("timeline");
        const ctx = canvas ? canvas.getContext("2d") : null;

        // ===== Cell Editor: Timeline click handler =====
        if (canvas) {
          canvas.addEventListener("click", (e) => {
          const rect = canvas.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const y = e.clientY - rect.top;
          
          const dpr = window.devicePixelRatio || 1;
          const canvasX = (x / rect.width) * canvas.width;
          const canvasW = canvas.width;
          const padX = Math.floor(canvasW * 0.05);
          const innerW = canvasW - padX * 2;
          
          // è¨ˆç®—é»æ“Šçš„æ˜¯å“ªä¸€æ‹
          const beatWidth = innerW / engine.beatsPerBar;
          const clickedBeat = Math.floor((canvasX - padX) / beatWidth);
          
          if (clickedBeat >= 0 && clickedBeat < engine.beatsPerBar) {
            const newMode = engine.cycleCellMode(clickedBeat);
            const cellDef = CELL_MODES[newMode];
            
            // æ›´æ–°æŒ‰éˆ•ç‹€æ…‹ï¼ˆæª¢æŸ¥æ‰€æœ‰ cell æ˜¯å¦éƒ½æ˜¯åŒä¸€æ¨¡å¼ï¼‰
            updateSegButtons();
            
            saveSettings();
            showToast(`ç¬¬ ${clickedBeat + 1} æ‹ï¼š${cellDef.label}`, 1000);
          }
          }, { passive: true });
        }

        // ===== UI Helpers =====
        function setStatePill(kind, text) {
          statePill.dataset.state = kind;
          stateText.textContent = text;
        }

        function setBpmUI(v, flash = false) {
          bpmValue.textContent = String(v);
          if (bpmSlider && Number(bpmSlider.value) !== v) {
            bpmSlider.value = String(v);
          }
        }

        function updateSegButtons(activeDiv) {
          // å¦‚æœæä¾›äº† activeDivï¼Œç›´æ¥ä½¿ç”¨å®ƒï¼ˆç”¨æ–¼æ‰‹å‹•é»æ“Šæˆ– Groove åˆ‡æ›ï¼‰
          if (activeDiv !== undefined && activeDiv !== null) {
            segBtns.forEach((b) => {
              const div = Number(b.dataset.division);
              b.setAttribute("aria-pressed", div === activeDiv ? "true" : "false");
            });
            return;
          }
          
          // å¦å‰‡æª¢æŸ¥æ‰€æœ‰ cell æ˜¯å¦éƒ½æ˜¯åŒä¸€æ¨¡å¼
          const firstMode = engine.getCellMode(0);
          let allSame = true;
          for (let i = 1; i < engine.beatsPerBar; i++) {
            if (engine.getCellMode(i) !== firstMode) {
              allSame = false;
              break;
            }
          }
          
          // å¦‚æœå…¨éƒ¨ç›¸åŒï¼Œé«˜äº®å°æ‡‰çš„æŒ‰éˆ•
          if (allSame) {
            const modeToDiv = {
              quarter: 1,
              eighth: 2,
              sixteenth: 4,
              triplet: 3,
            };
            const expectedDiv = modeToDiv[firstMode];
            if (expectedDiv) {
              segBtns.forEach((b) => {
                const div = Number(b.dataset.division);
                b.setAttribute("aria-pressed", div === expectedDiv ? "true" : "false");
              });
            } else {
              // å¦‚æœæ¨¡å¼ä¸åŒ¹é…ï¼Œå…¨éƒ¨å–æ¶ˆé«˜äº®
              segBtns.forEach((b) => {
                b.setAttribute("aria-pressed", "false");
              });
            }
          } else {
            // å¦‚æœæ··æ­ï¼Œå…¨éƒ¨å–æ¶ˆé«˜äº®
            segBtns.forEach((b) => {
              b.setAttribute("aria-pressed", "false");
            });
          }
        }

        function updateGrooveButtons(activeName) {
          grooveBtns.forEach((b) => {
            const g = b.dataset.groove;
            b.setAttribute("aria-pressed", g === activeName ? "true" : "false");
          });
        }

        function setSegNote(msg = "") {
          segNote.textContent = msg;
        }

        function updateTimelineMeta() {
          const groove = GROOVE_PRESETS[engine.grooveName] || GROOVE_PRESETS.standard;
          const info = engine._lastScheduledInfo;
          const cellLabel = info.cellMode ? CELL_MODES[info.cellMode]?.label || "" : "";
          
          let metaText = `4/4 Â· ${cellLabel || formatDivision(engine.division)} Â· ${groove.label} Â· Bar ${info.bar}`;
          
          // å¦‚æœæ­£åœ¨æ’­æ”¾ï¼Œæ·»åŠ  Beat å’Œ Downbeat ä¿¡æ¯ï¼ˆä¸æ˜¾ç¤º Subï¼‰
          if (engine.audio && engine.isPlaying) {
            const { bar, beat, isDownbeat, isGhost } = engine._lastScheduledInfo;
            metaText += ` Â· Beat ${beat}${isDownbeat ? " Â· Downbeat" : ""}`;
            if (engine.ghostMode && (isGhost || engine._ghostState.isGhosting)) {
              metaText += " Â· ğŸ‘» Ghost";
            }
            if (engine.progressiveMode) {
              metaText += " Â· â¬† Progressive";
            }
          }
          
          timelineMeta.textContent = metaText;
        }

        function dprResizeCanvas() {
          const dpr = window.devicePixelRatio || 1;
          const rect = canvas.getBoundingClientRect();
          const w = Math.max(1, Math.floor(rect.width * dpr));
          const h = Math.max(1, Math.floor(rect.height * dpr));
          if (canvas.width !== w || canvas.height !== h) {
            canvas.width = w;
            canvas.height = h;
          }
        }

        // ===== Timeline Rendering =====
        function drawTimeline() {
          if (!canvas || !ctx) return;
          dprResizeCanvas();
          const w = canvas.width;
          const h = canvas.height;
          ctx.clearRect(0, 0, w, h);

          // background
          ctx.fillStyle = "rgba(255,255,255,0.03)";
          ctx.fillRect(0, 0, w, h);

          const padX = Math.floor(w * 0.05);
          const padY = Math.floor(h * 0.18);
          const innerW = w - padX * 2;
          const midY = Math.floor(h * 0.58);

          // subtle baseline
          ctx.strokeStyle = "rgba(255,255,255,0.10)";
          ctx.lineWidth = Math.max(1, Math.floor((window.devicePixelRatio || 1)));
          ctx.beginPath();
          ctx.moveTo(padX, midY);
          ctx.lineTo(padX + innerW, midY);
          ctx.stroke();

          // ç¹ªè£½æ¯ä¸€æ‹çš„ cell blocksï¼ˆæ ¹æ“š cellModesï¼‰
          const beatWidth = innerW / engine.beatsPerBar;
          for (let beatIdx = 0; beatIdx < engine.beatsPerBar; beatIdx++) {
            const beatStartX = padX + beatWidth * beatIdx;
            const cellMode = engine.getCellMode(beatIdx);
            const cellDef = CELL_MODES[cellMode];
            const isDownbeat = beatIdx === 0;

            // è¨ˆç®—é€™å€‹ cell æ‡‰è©²æœ‰å¤šå°‘å€‹ block
            const blocksPerBeat = cellDef.div;
            const blockWidth = beatWidth / blocksPerBeat * 0.85; // ç¨å¾®ç•™ç©ºéš™
            const blockSpacing = beatWidth / blocksPerBeat;

            // ç²å–ç•¶å‰é¢¨æ ¼çš„é‡éŸ³æ¨¡å¼
            const preset = GROOVE_PRESETS[engine.grooveName] || GROOVE_PRESETS.standard;
            const pattern = preset.pattern4 || GROOVE_PRESETS.standard.pattern4;
            
            for (let blockIdx = 0; blockIdx < blocksPerBeat; blockIdx++) {
              const centerX = beatStartX + blockSpacing * (blockIdx + 0.5);
              const x = centerX - blockWidth / 2;

              // è¨ˆç®—ç•¶å‰ block çš„é‡éŸ³ç´šåˆ¥ï¼ˆèˆ‡è²éŸ³æ’­æ”¾é‚è¼¯ä¸€è‡´ï¼‰
              let accentLevel = 0;
              const isBeatBoundary = blockIdx === 0;
              
              if (isBeatBoundary) {
                // æ‹é»ï¼ˆon-beatï¼‰ï¼šä½¿ç”¨ pattern çš„é‡éŸ³ç´šåˆ¥
                if (engine.grooveName === "reggae") {
                  // Reggae ç‰¹æ®Šè™•ç†ï¼šé‡éŸ³åœ¨ off-beatï¼Œæ‰€ä»¥ on-beat é™ä½é‡éŸ³
                  const beatAccent = pattern[beatIdx % pattern.length] ?? 1;
                  if (beatAccent >= 2) {
                    accentLevel = 1; // ç¬¬ 2ã€4 æ‹çš„ on-beat é™ç‚ºä¸­ç­‰é‡éŸ³ï¼ˆé‡éŸ³åœ¨ off-beatï¼‰
                  } else {
                    accentLevel = beatAccent; // å…¶ä»–æ‹ä¿æŒåŸæ¨£
                  }
                } else {
                  accentLevel = pattern[beatIdx % pattern.length] ?? 1;
                }
              } else {
                // ç´°åˆ†é»ï¼ˆoff-beat æˆ–å…¶ä»–ç´°åˆ†ï¼‰
                if (engine.grooveName === "reggae") {
                  // Reggae ç‰¹æ®Šè™•ç†ï¼šç¬¬ 2ã€4 æ‹çš„åæ‹ï¼ˆoff-beatï¼‰æœ‰å¼·é‡éŸ³
                  // æ”¯æŒæ‰€æœ‰ç´°åˆ†ï¼š1/8, 1/16, triplet
                  // è¨ˆç®— posInBeatï¼ˆåœ¨ 1/48 ç¶²æ ¼ä¸­çš„ä½ç½®ï¼‰
                  const posInBeat = blockIdx * (48 / blocksPerBeat);
                  
                  if (engine._isReggaeOffbeat(cellMode, posInBeat)) {
                    const beatAccent = pattern[beatIdx % pattern.length] ?? 1;
                    if (beatAccent >= 2) {
                      accentLevel = 2; // ç¬¬ 2ã€4 æ‹çš„ off-beat æ˜¯å¼·é‡éŸ³ï¼ˆå¾ŒåŠæ‹å¼·èª¿ï¼‰
                    } else {
                      accentLevel = 0; // å…¶ä»–æ‹çš„ off-beat ç„¡é‡éŸ³
                    }
                  } else {
                    accentLevel = 0; // å…¶ä»–ç´°åˆ†é»ç„¡é‡éŸ³
                  }
                } else {
                  // å…¶ä»–é¢¨æ ¼ï¼šç´°åˆ†é»é€šå¸¸ç„¡é‡éŸ³
                  accentLevel = 0;
                }
              }

              // æ ¹æ“šé‡éŸ³ç´šåˆ¥æ±ºå®š block é«˜åº¦å’Œé¡è‰²ï¼ˆèˆ‡è²éŸ³æ’­æ”¾ä¸€è‡´ï¼‰
              let blockHeight, fillColor;
              if (accentLevel >= 2) {
                // å¼·é‡éŸ³ï¼ˆlevel 2ï¼‰ï¼šå†°è—è‰²
                blockHeight = h * 0.35; // å¾ 0.42 æ¸›å°åˆ° 0.35ï¼Œé¿å…é®æ“‹æ–‡å­—
                fillColor = "rgba(0,229,255,0.95)";
              } else if (accentLevel === 1) {
                // ä¸­ç­‰é‡éŸ³ï¼ˆlevel 1ï¼‰ï¼šç´«è‰²
                blockHeight = h * 0.25; // å¾ 0.30 æ¸›å°åˆ° 0.25
                fillColor = "rgba(255,255,255,0.80)";
              } else {
                // ç„¡é‡éŸ³ï¼ˆlevel 0ï¼‰ï¼šæ·¡ç™½è‰²
                blockHeight = h * 0.16; // å¾ 0.20 æ¸›å°åˆ° 0.16
                fillColor = "rgba(255,255,255,0.26)";
              }

              const y = midY - blockHeight;

              ctx.fillStyle = fillColor;
              if (typeof ctx.roundRect === "function") {
                ctx.beginPath();
                ctx.roundRect(x, y, blockWidth, blockHeight * 1.15, Math.min(blockWidth, blockHeight * 0.3)); // å¾ 1.25 æ¸›å°åˆ° 1.15
                ctx.fill();
              } else {
                ctx.fillRect(x, y, blockWidth, blockHeight * 1.15); // å¾ 1.25 æ¸›å°åˆ° 1.15
              }
            }

            // åœ¨æ¯ä¸€æ‹ä¸Šæ–¹é¡¯ç¤ºæ¨¡å¼æ¨™ç±¤ï¼ˆå°å­—ï¼‰
            // ç¢ºä¿æ–‡å­—åœ¨é ‚éƒ¨ï¼Œä¸è¢«æ–¹å¡Šé®æ“‹
            ctx.fillStyle = "rgba(255,255,255,0.55)"; // ç¨å¾®æé«˜å°æ¯”åº¦
            ctx.font = `${Math.floor(h * 0.075)}px ui-sans-serif, system-ui, -apple-system`; // ç¨å¾®æ¸›å°å­—é«”
            ctx.textAlign = "center";
            ctx.textBaseline = "top";
            ctx.fillText(cellDef.label, beatStartX + beatWidth / 2, padY * 0.5); // å¾ 0.6 èª¿æ•´åˆ° 0.5ï¼Œæ›´é è¿‘é ‚éƒ¨
          }

          // playhead / progress
          if (engine.audio && engine.isPlaying) {
            const audioNow = engine.audio.currentTime;
            const microInterval = engine._microIntervalSec();
            const since = Math.max(0, audioNow - engine.lastTickTime);

            // å¾ microIndex è¨ˆç®—ä½ç½®
            const microsPerBar = engine.beatsPerBar * engine.microDiv;
            const currentMicroInBar = engine.microIndex % microsPerBar;
            const progressWithinMicro = clamp(since / microInterval, 0, 1.25);
            const x = padX + innerW * ((currentMicroInBar + progressWithinMicro) / microsPerBar);

            // Ghost Mode: æª¢æŸ¥æ˜¯å¦åœ¨ ghost ç‹€æ…‹
            const info = engine._lastScheduledInfo;
            const isGhost = engine.ghostMode && (info.isGhost || engine._ghostState.isGhosting);

            if (!isGhost) {
              // æ­£å¸¸ç‹€æ…‹ï¼šé¡¯ç¤º playhead
              // glow
              const grad = ctx.createRadialGradient(x, midY, 0, x, midY, innerW * 0.08);
              grad.addColorStop(0, "rgba(0,229,255,0.22)");
              grad.addColorStop(1, "rgba(0,229,255,0)");
              ctx.fillStyle = grad;
              ctx.fillRect(padX, 0, innerW, h);

              ctx.strokeStyle = "rgba(0,229,255,0.95)";
              ctx.lineWidth = 2 * (window.devicePixelRatio || 1);
              ctx.beginPath();
              ctx.moveTo(x, padY);
              ctx.lineTo(x, h - padY);
              ctx.stroke();
            } else {
              // Ghost ç‹€æ…‹ï¼šéš±è— playheadï¼ˆæ™‚é–“è»¸ç¹¼çºŒå‰é€²ï¼Œä½†è¦–è¦ºéœéŸ³ï¼‰
              // å¯é¸ï¼šé¡¯ç¤ºä¸€å€‹éå¸¸æ·¡çš„æç¤º
              ctx.strokeStyle = "rgba(255,255,255,0.08)";
              ctx.lineWidth = 1 * (window.devicePixelRatio || 1);
              ctx.setLineDash([4, 4]);
              ctx.beginPath();
              ctx.moveTo(x, padY);
              ctx.lineTo(x, h - padY);
              ctx.stroke();
              ctx.setLineDash([]);
            }
          }
        }

        function rafLoop() {
          drawTimeline();
          
          // Progressive Mode: æª¢æŸ¥æ˜¯å¦éœ€è¦è§¸ç™¼æç¤º
          if (engine._shouldFlashBpm) {
            setBpmUI(engine.bpm);
            engine._shouldFlashBpm = false;
            showToast(`BPM æå‡è‡³ ${engine.bpm}`, 1200);
          }
          
          updateTimelineMeta();
          requestAnimationFrame(rafLoop);
        }

        // ===== Scheduler callback (optional; reserved for future UI sync) =====
        function onScheduledTick(evt) {
          state.ui.lastScheduledTick = evt;
        }

        // ===== Controls =====
        function refreshPlayUI() {
          if (engine.isPlaying) {
            btnPlay.classList.add("playing");
            playLabel.textContent = "STOP";
            playSub.textContent = "";
            setStatePill("playing", "æ’­æ”¾ä¸­");
          } else {
            btnPlay.classList.remove("playing");
            playLabel.textContent = "START";
            playSub.textContent = engine.audio && engine.audio.state === "running" ? "" : "é»æ“Šä»¥è§£é–éŸ³è¨Š";
            setStatePill("stopped", "STANDBY");
          }
        }

        async function togglePlay() {
          try {
            await engine.ensureAudioUnlocked();
          } catch (e) {
            showToast("éŸ³è¨Šåˆå§‹åŒ–å¤±æ•—ï¼ˆè«‹æª¢æŸ¥éœéŸ³/æ¬Šé™ï¼‰");
            return;
          }

          if (engine.isPlaying) {
            engine.stop();
            refreshPlayUI();
            return;
          }

          engine.start(onScheduledTick);
          refreshPlayUI();
          setSegNote("");
        }

        btnPlay.addEventListener("click", togglePlay, { passive: true });

        // BPM drag (horizontal)
        (() => {
          let dragging = false;
          let startX = 0;
          let startBpm = engine.bpm;
          let lastApplied = engine.bpm;

          const onDown = (e) => {
            dragging = true;
            bpmDrag.setPointerCapture?.(e.pointerId);
            startX = e.clientX;
            startBpm = engine.bpm;
            lastApplied = engine.bpm;
          };
          const onMove = (e) => {
            if (!dragging) return;
            const dx = e.clientX - startX;
            // 16px per BPM, accelerate slightly
            const next = clamp(Math.round(startBpm + dx / 16), 40, 240);
            if (next !== lastApplied) {
              engine.setBpm(next);
              setBpmUI(engine.bpm);
              lastApplied = next;
              saveSettings();
            }
          };
          const onUp = () => {
            dragging = false;
            saveSettings();
          };

          bpmDrag.addEventListener("pointerdown", onDown);
          window.addEventListener("pointermove", onMove, { passive: true });
          window.addEventListener("pointerup", onUp, { passive: true });
          window.addEventListener("pointercancel", onUp, { passive: true });
        })();

        // BPM slider
        if (bpmSlider) {
          bpmSlider.addEventListener("input", (e) => {
            const v = Number(e.target.value || engine.bpm);
            engine.setBpm(v);
            setBpmUI(engine.bpm);
            saveSettings();
          }, { passive: true });
        }

        // Swing slider
        function setSwingUI(v) {
          if (swingValue) {
            swingValue.textContent = `${v}%`;
          }
        }
        if (swingSlider) {
          swingSlider.addEventListener("input", (e) => {
            const v = Number(e.target.value || 0);
            engine.setSwing(v);
            setSwingUI(engine.swing);
            saveSettings();
          }, { passive: true });
        }

        // Tap Tempo (æ‹é€Ÿæ£€æµ‹)
        (() => {
          const tapTimes = [];
          const maxTaps = 8; // æœ€å¤šä¿ç•™ 8 æ¬¡ç‚¹å‡»
          const resetTimeout = 2000; // 2 ç§’æ— ç‚¹å‡»åˆ™é‡ç½®
          let resetTimer = null;

          function calculateBPM() {
            if (tapTimes.length < 2) return null;
            
            // è®¡ç®—æ‰€æœ‰é—´éš”çš„å¹³å‡å€¼
            const intervals = [];
            for (let i = 1; i < tapTimes.length; i++) {
              intervals.push(tapTimes[i] - tapTimes[i - 1]);
            }
            
            const avgInterval = intervals.reduce((a, b) => a + b, 0) / intervals.length;
            const bpm = Math.round(60000 / avgInterval); // è½¬æ¢ä¸º BPM
            
            // é™åˆ¶åœ¨æœ‰æ•ˆèŒƒå›´å†…
            return clamp(bpm, 40, 240);
          }

          function resetTaps() {
            tapTimes.length = 0;
            if (resetTimer) {
              clearTimeout(resetTimer);
              resetTimer = null;
            }
          }

          function handleTap() {
            const now = Date.now();
            
            // å¦‚æœè·ç¦»ä¸Šæ¬¡ç‚¹å‡»è¶…è¿‡é‡ç½®æ—¶é—´ï¼Œæ¸…ç©ºè®°å½•
            if (tapTimes.length > 0 && now - tapTimes[tapTimes.length - 1] > resetTimeout) {
              resetTaps();
            }
            
            // æ·»åŠ å½“å‰ç‚¹å‡»æ—¶é—´
            tapTimes.push(now);
            
            // é™åˆ¶è®°å½•æ•°é‡
            if (tapTimes.length > maxTaps) {
              tapTimes.shift();
            }
            
            // è®¡ç®— BPM
            const bpm = calculateBPM();
            if (bpm !== null) {
              engine.setBpm(bpm);
              setBpmUI(engine.bpm);
              saveSettings();
              showToast(`Tap Tempo: ${bpm} BPM`, 800);
            } else if (tapTimes.length === 1) {
              showToast("ç¹¼çºŒé»æ“Šä»¥æª¢æ¸¬ BPM", 1000);
            }
            
            // é‡ç½®å®šæ—¶å™¨
            if (resetTimer) {
              clearTimeout(resetTimer);
            }
            resetTimer = setTimeout(() => {
              resetTaps();
              showToast("Tap Tempo å·²é‡ç½®", 800);
            }, resetTimeout);
          }

          if (tapTempoBtn) {
            tapTempoBtn.addEventListener("click", handleTap, { passive: true });
            // æ”¯æŒé”®ç›˜ç©ºæ ¼é”®ï¼ˆä»…åœ¨æœªæ’­æ”¾æ—¶ä¸”ç„¦ç‚¹åœ¨ body ä¸Šï¼‰
            const tapTempoKeyHandler = (e) => {
              // åªåœ¨æœªæ’­æ”¾ã€ç„¦ç‚¹åœ¨ bodyã€ä¸”ä¸æ˜¯è¾“å…¥æ¡†æ—¶è§¦å‘
              if (e.code === "Space" && 
                  e.target === document.body && 
                  !engine.isPlaying &&
                  e.target.tagName !== "INPUT" &&
                  e.target.tagName !== "TEXTAREA") {
                e.preventDefault();
                handleTap();
              }
            };
            document.addEventListener("keydown", tapTempoKeyHandler, { passive: false });
          }
        })();

        // Division buttons (now act as templates for all cells)
        segBtns.forEach((b) => {
          b.addEventListener("click", () => {
            const div = Number(b.dataset.division);
            
            // Map division to cell mode
            let mode;
            if (div === 1) mode = "quarter";
            else if (div === 2) mode = "eighth";
            else if (div === 4) mode = "sixteenth";
            else if (div === 3) mode = "triplet";
            else mode = "quarter";

            // Set all cells to this mode (template) - å…ˆè¨­ç½®ï¼Œå†æ›´æ–° UI
            engine.setAllCellsToMode(mode);
            engine.division = div; // Keep legacy for compatibility
            
            // æ›´æ–°æŒ‰éˆ•ç‹€æ…‹ï¼ˆåœ¨è¨­ç½® cell modes ä¹‹å¾Œï¼‰
            updateSegButtons(div);
            
            saveSettings();
            
            setSegNote(`å·²å¥—ç”¨æ¨¡æ¿ï¼š${formatDivision(div)}ï¼ˆæ•´å°ç¯€ï¼‰`);
            window.setTimeout(() => setSegNote(""), 1300);
            showToast(`æ¨¡æ¿ï¼š${formatDivision(div)}`, 900);
          }, { passive: true });
        });

        // Groove presets (Standard / Boom Bap / Trap / Reggae)
        // æ³¨æ„ï¼šåˆ‡æ›é¢¨æ ¼æ™‚ä¸æœƒè‡ªå‹•ç¶å®šéŸ³ç¬¦ï¼Œä¿æŒç”¨æˆ¶ç•¶å‰çš„ç´°åˆ†è¨­ç½®
        grooveBtns.forEach((b) => {
          b.addEventListener("click", () => {
            const grooveName = b.dataset.groove;
            if (!GROOVE_PRESETS[grooveName]) return;

            engine.setGroove(grooveName);
            updateGrooveButtons(grooveName);
            saveSettings();
            
            const preset = GROOVE_PRESETS[grooveName];
            showToast(`Grooveï¼š${preset.label}`, 1000);
          }, { passive: true });
        });


        // Ghost Mode toggle
        if (ghostModeToggle) {
          ghostModeToggle.addEventListener("change", (e) => {
            const enabled = e.target.checked;
            engine.setGhostMode(enabled);
            saveSettings();
            if (enabled) {
              showToast("Ghost Mode å·²é–‹å•Ÿï¼šéš¨æ©Ÿç©ºæ‹è¨“ç·´", 1500);
            } else {
              showToast("Ghost Mode å·²é—œé–‰", 1000);
            }
          }, { passive: true });
        }

        // Progressive Training Mode toggle
        if (progressiveModeToggle) {
          progressiveModeToggle.addEventListener("change", (e) => {
            const enabled = e.target.checked;
            engine.setProgressiveMode(enabled);
            if (enabled) {
              engine.initialBpm = engine.bpm;
              engine._lastProgressiveBar = 0;
              showToast("Progressive Mode å·²é–‹å•Ÿï¼šæ¯ 4 å°ç¯€è‡ªå‹•æé€Ÿ +2 BPM", 2000);
            } else {
              engine.bpm = engine.initialBpm;
              setBpmUI(engine.bpm);
              showToast("Progressive Mode å·²é—œé–‰ï¼šBPM å·²æ¢å¾©", 1500);
            }
            saveSettings();
          }, { passive: true });
        }

        // Background/foreground handling: iOS may throttle timers in background.
        document.addEventListener("visibilitychange", () => {
          if (document.hidden) {
            state.wasPlayingBeforeHide = engine.isPlaying;
            if (engine.isPlaying) {
              engine.stop();
              setStatePill("paused", "èƒŒæ™¯ä¸­å·²æš«åœ");
              showToast("åˆ‡åˆ°èƒŒæ™¯ï¼šå·²æš«åœä»¥é¿å…ç¯€æ‹é£„ç§»");
              refreshPlayUI();
            }
          } else {
            if (state.wasPlayingBeforeHide) {
              // If audio is already unlocked earlier, we can resume without extra gesture in most cases.
              // Still, resume might fail if iOS suspended audio; we'll try.
              engine.ensureAudioUnlocked()
                .then(() => {
                  engine.start(onScheduledTick);
                  refreshPlayUI();
                  showToast("å›åˆ°å‰å°ï¼šå·²é‡æ–°åŒæ­¥");
                })
                .catch(() => {
                  showToast("å›åˆ°å‰å°ï¼šè«‹æŒ‰ PLAY é‡æ–°é–‹å§‹");
                })
                .finally(() => {
                  state.wasPlayingBeforeHide = false;
                });
            }
          }
        });

        // Prevent double-tap zoom-ish behavior on iOS for controls (still allows pinch zoom overall)
        document.addEventListener("gesturestart", (e) => {
          // iOS Safari only
          e.preventDefault();
        }, { passive: false });

        // ===== PWA: register service worker =====
        if ("serviceWorker" in navigator) {
          window.addEventListener("load", () => {
            navigator.serviceWorker.register("./sw.js").catch(() => {
              // ignore
            });
          });
        }

        // Load saved settings and restore UI
        const loadedSettings = loadSettings();
        
        // Update UI based on loaded/current settings
        setBpmUI(engine.bpm);
        setSwingUI(engine.swing);
        updateSegButtons(engine.division);
        updateGrooveButtons(engine.grooveName);
        
        // Restore toggle states
        if (ghostModeToggle) {
          ghostModeToggle.checked = engine.ghostMode;
        }
        if (progressiveModeToggle) {
          progressiveModeToggle.checked = engine.progressiveMode;
        }
        
        // Update swing slider if it exists
        if (swingSlider) {
          swingSlider.value = engine.swing;
        }
        
        refreshPlayUI();
        
        if (loadedSettings) {
          showToast("å·²æ¢å¾©ä¸Šæ¬¡è¨­å®š", 1500);
        }
        
        rafLoop();

        // Tell user if not HTTPS / SW limitations (desktop dev)
        if (location.protocol !== "https:" && location.hostname !== "localhost") {
          // Service worker requires secure context; iOS A2HS may still work via local file, but offline caching won't.
          showToast("æç¤ºï¼šService Worker éœ€è¦ HTTPS æ‰èƒ½é›¢ç·šå¿«å–", 2200);
        }

        // ===== Calendar System =====
        let currentCalendarDate = new Date();
        
        function formatDuration(seconds) {
          if (seconds < 60) return `${seconds}ç§’`;
          const minutes = Math.floor(seconds / 60);
          const secs = seconds % 60;
          if (secs === 0) return `${minutes}åˆ†é˜`;
          return `${minutes}åˆ†${secs}ç§’`;
        }
        
        function formatDurationShort(seconds) {
          if (seconds < 60) return `${seconds}s`;
          const minutes = Math.floor(seconds / 60);
          return `${minutes}m`;
        }
        
        function formatTime(isoString) {
          const d = new Date(isoString);
          return `${String(d.getHours()).padStart(2, '0')}:${String(d.getMinutes()).padStart(2, '0')}`;
        }
        
        function updateDailyGoalProgress() {
          const { duration, goal } = DailyGoal.getTodayProgress();
          const percent = DailyGoal.getProgressPercent();
          const minutes = Math.floor(duration / 60);
          const goalMinutes = Math.floor(goal / 60);
          
          // æ›´æ–°ä¸»ç•Œé¢è¿›åº¦æ¡
          if (dailyGoalProgressText) {
            dailyGoalProgressText.textContent = `${minutes} / ${goalMinutes} åˆ†é’Ÿ`;
          }
          if (dailyGoalProgressPercent) {
            dailyGoalProgressPercent.textContent = `${percent}%`;
          }
          if (dailyGoalProgressFill) {
            dailyGoalProgressFill.style.width = `${percent}%`;
            if (percent >= 100) {
              dailyGoalProgressFill.classList.add('complete');
            } else {
              dailyGoalProgressFill.classList.remove('complete');
            }
          }
          
          // æ›´æ–°æ—¥å†ä¸­çš„è¿›åº¦æ¡
          if (calendarDailyGoalProgressText) {
            calendarDailyGoalProgressText.textContent = `${minutes} / ${goalMinutes} åˆ†é’Ÿ`;
          }
          if (calendarDailyGoalProgressPercent) {
            calendarDailyGoalProgressPercent.textContent = `${percent}%`;
          }
          if (calendarDailyGoalProgressFill) {
            calendarDailyGoalProgressFill.style.width = `${percent}%`;
            if (percent >= 100) {
              calendarDailyGoalProgressFill.classList.add('complete');
            } else {
              calendarDailyGoalProgressFill.classList.remove('complete');
            }
          }
        }
        
        function renderCalendarStats() {
          const stats = TrainingCalendar.getStats();
          const bpmStats = TrainingCalendar.getBpmRangeStats();
          
          // è®¡ç®—BPMç»Ÿè®¡çš„æ˜¾ç¤ºï¼ˆæœ€å¤šæ˜¾ç¤ºå‰5ä¸ªæœ€é•¿çš„åŒºé—´ï¼‰
          const topBpmRanges = bpmStats
            .sort((a, b) => b.duration - a.duration)
            .slice(0, 5);
          
          let bpmStatsHtml = '';
          if (topBpmRanges.length > 0) {
            bpmStatsHtml = topBpmRanges.map(range => `
              <div class="calendarBpmStatItem">
                <div class="calendarBpmStatLabel">${range.start}-${range.end} BPM</div>
                <div class="calendarBpmStatValue">${formatDuration(range.duration)}</div>
              </div>
            `).join('');
          } else {
            bpmStatsHtml = '<div class="calendarBpmStatItem" style="grid-column: 1 / -1; color: var(--muted2); font-size: 11px;">æš«ç„¡æ•¸æ“š</div>';
          }
          
          calendarStats.innerHTML = `
            <div class="calendarStatItem">
              <div class="calendarStatLabel">ç¸½è¨“ç·´å¤©æ•¸</div>
              <div class="calendarStatValue">${stats.daysWithTraining}</div>
            </div>
            <div class="calendarStatItem">
              <div class="calendarStatLabel">ç¸½è¨“ç·´æ™‚é•·</div>
              <div class="calendarStatValue">${formatDuration(stats.totalDuration)}</div>
            </div>
            <div class="calendarBpmStatsSection">
              <div class="calendarBpmStatsTitle">BPM ç·´ç¿’æ™‚é•·</div>
              <div class="calendarBpmStatsGrid">
                ${bpmStatsHtml}
              </div>
            </div>
          `;
        }
        
        function renderCalendar() {
          const year = currentCalendarDate.getFullYear();
          const month = currentCalendarDate.getMonth();
          
          // æ›´æ–°æœˆä»½å¹´ä»½æ˜¾ç¤º
          const monthNames = ['ä¸€æœˆ', 'äºŒæœˆ', 'ä¸‰æœˆ', 'å››æœˆ', 'äº”æœˆ', 'å…­æœˆ', 'ä¸ƒæœˆ', 'å…«æœˆ', 'ä¹æœˆ', 'åæœˆ', 'åä¸€æœˆ', 'åäºŒæœˆ'];
          calendarMonthYear.textContent = `${year}å¹´ ${monthNames[month]}`;
          
          // è·å–æœˆä»½æ•°æ®
          const monthData = TrainingCalendar.getMonthData(year, month + 1);
          
          // è®¡ç®—æ—¥å†ç¬¬ä¸€å¤©å’Œæœ€åä¸€å¤©
          const firstDay = new Date(year, month, 1);
          const lastDay = new Date(year, month + 1, 0);
          const firstDayOfWeek = firstDay.getDay(); // 0 = æ˜ŸæœŸæ—¥
          const daysInMonth = lastDay.getDate();
          
          // æ¸…ç©ºæ—¥å†
          calendarGrid.innerHTML = '';
          
          // æ·»åŠ æ˜ŸæœŸæ ‡é¢˜
          const dayHeaders = ['æ—¥', 'ä¸€', 'äºŒ', 'ä¸‰', 'å››', 'äº”', 'å…­'];
          dayHeaders.forEach(day => {
            const header = document.createElement('div');
            header.className = 'calendarDayHeader';
            header.textContent = day;
            calendarGrid.appendChild(header);
          });
          
          // æ·»åŠ ä¸Šä¸ªæœˆçš„æ—¥æœŸï¼ˆå¡«å……ç¬¬ä¸€å‘¨ï¼‰
          const prevMonth = new Date(year, month - 1, 0);
          const daysInPrevMonth = prevMonth.getDate();
          for (let i = firstDayOfWeek - 1; i >= 0; i--) {
            const day = daysInPrevMonth - i;
            const date = new Date(year, month - 1, day);
            const dayEl = createCalendarDay(date, true, monthData);
            calendarGrid.appendChild(dayEl);
          }
          
          // æ·»åŠ å½“å‰æœˆçš„æ—¥æœŸ
          const today = new Date();
          for (let day = 1; day <= daysInMonth; day++) {
            const date = new Date(year, month, day);
            const isToday = date.toDateString() === today.toDateString();
            const dayEl = createCalendarDay(date, false, monthData, isToday);
            calendarGrid.appendChild(dayEl);
          }
          
          // æ·»åŠ ä¸‹ä¸ªæœˆçš„æ—¥æœŸï¼ˆå¡«å……æœ€åä¸€å‘¨ï¼‰
          const totalCells = calendarGrid.children.length - 7; // å‡å»æ˜ŸæœŸæ ‡é¢˜
          const remainingCells = 42 - totalCells; // 6è¡Œ x 7åˆ— = 42
          for (let day = 1; day <= remainingCells; day++) {
            const date = new Date(year, month + 1, day);
            const dayEl = createCalendarDay(date, true, monthData);
            calendarGrid.appendChild(dayEl);
          }
        }
        
        function createCalendarDay(date, isOtherMonth, monthData, isToday = false) {
          const dayEl = document.createElement('div');
          dayEl.className = 'calendarDay';
          
          const dateKey = TrainingCalendar.getDateKey(date);
          const dayData = monthData[dateKey];
          const bpmRanges = dayData ? TrainingCalendar.getDateDataByBpmRange(date) : {};
          const hasTraining = Object.keys(bpmRanges).length > 0;
          const goalAchieved = DailyGoal.isGoalAchieved(date);
          
          if (isOtherMonth) dayEl.classList.add('otherMonth');
          if (isToday) dayEl.classList.add('today');
          if (hasTraining) dayEl.classList.add('hasTraining');
          if (goalAchieved) dayEl.classList.add('goalAchieved');
          
          // æ—¥æœŸæ•°å­—
          const dayNumber = document.createElement('div');
          dayNumber.className = 'calendarDayNumber';
          dayNumber.textContent = date.getDate();
          dayEl.appendChild(dayNumber);
          
          if (hasTraining && dayData) {
            // æ˜¾ç¤ºæ€»è®­ç»ƒæ¬¡æ•°å’Œæ€»æ—¶é•¿
            const totalSessions = dayData.totalSessions || 0;
            const totalDuration = dayData.totalDuration || 0;
            
            // è®­ç»ƒæ¬¡æ•°
            const sessionsBadge = document.createElement('div');
            sessionsBadge.className = 'calendarDaySessions';
            sessionsBadge.textContent = `${totalSessions}æ¬¡`;
            dayEl.appendChild(sessionsBadge);
            
            // æ€»æ—¶é•¿
            const duration = document.createElement('div');
            duration.className = 'calendarDayDuration';
            duration.textContent = formatDurationShort(totalDuration);
            dayEl.appendChild(duration);
          }
          
          dayEl.addEventListener('click', () => {
            if (hasTraining && dayData) {
              showDayDetail(dateKey, dayData);
            } else {
              calendarDayDetail.style.display = 'none';
            }
          });
          
          return dayEl;
        }
        
        function showDayDetail(dateKey, dayData) {
          calendarDayDetail.style.display = 'block';
          
          const date = new Date(dateKey + 'T00:00:00');
          const dateStr = `${date.getFullYear()}å¹´${date.getMonth() + 1}æœˆ${date.getDate()}æ—¥`;
          
          // æŒ‰é£æ ¼åˆ†ç»„ç»Ÿè®¡
          const byGroove = {};
          const byBpmRange = {};
          let totalBpm = 0;
          let progressiveCount = 0;
          let ghostCount = 0;
          
          dayData.sessions.forEach(session => {
            // æŒ‰é£æ ¼åˆ†ç»„
            const groove = session.groove || 'standard';
            if (!byGroove[groove]) {
              byGroove[groove] = {
                groove: groove,
                sessions: [],
                totalDuration: 0,
                count: 0,
              };
            }
            byGroove[groove].sessions.push(session);
            byGroove[groove].totalDuration += session.duration || 0;
            byGroove[groove].count += 1;
            
            // æŒ‰BPMèŒƒå›´åˆ†ç»„
            const avgBpm = session.progressiveMode && session.finalBpm 
              ? Math.round((session.bpm + session.finalBpm) / 2)
              : session.bpm;
            const range = TrainingCalendar.getBpmRange(avgBpm);
            const rangeKey = `${range.start}-${range.end}`;
            if (!byBpmRange[rangeKey]) {
              byBpmRange[rangeKey] = {
                range: rangeKey,
                start: range.start,
                end: range.end,
                totalDuration: 0,
                count: 0,
              };
            }
            byBpmRange[rangeKey].totalDuration += session.duration || 0;
            byBpmRange[rangeKey].count += 1;
            
            totalBpm += avgBpm;
            if (session.progressiveMode) progressiveCount++;
            if (session.ghostMode) ghostCount++;
          });
          
          const avgBpm = Math.round(totalBpm / dayData.sessions.length);
          
          // æŒ‰5 BPMåŒºé—´ç»Ÿè®¡
          const bpmRangeStats = Object.values(byBpmRange)
            .sort((a, b) => a.start - b.start)
            .filter(range => range.duration > 0);
          
          // ç”ŸæˆHTML
          let html = `
            <div class="calendarDayDetailTitle">${dateStr}</div>
            <div class="calendarDayDetailSummary">
              <div class="calendarDayDetailSummaryItem">
                <div class="calendarDayDetailSummaryLabel">è¨“ç·´æ¬¡æ•¸</div>
                <div class="calendarDayDetailSummaryValue">${dayData.totalSessions}æ¬¡</div>
              </div>
              <div class="calendarDayDetailSummaryItem">
                <div class="calendarDayDetailSummaryLabel">ç¸½æ™‚é•·</div>
                <div class="calendarDayDetailSummaryValue">${formatDuration(dayData.totalDuration)}</div>
              </div>
              <div class="calendarDayDetailSummaryItem">
                <div class="calendarDayDetailSummaryLabel">å¹³å‡BPM</div>
                <div class="calendarDayDetailSummaryValue">${avgBpm}</div>
              </div>
              <div class="calendarDayDetailSummaryItem">
                <div class="calendarDayDetailSummaryLabel">é£æ ¼æ•°</div>
                <div class="calendarDayDetailSummaryValue">${Object.keys(byGroove).length}ç§</div>
              </div>
            </div>
          `;
          
          // æ·»åŠ BPMåŒºé—´ç»Ÿè®¡
          if (bpmRangeStats.length > 0) {
            html += `
              <div class="calendarBpmRangeSection">
                <div class="calendarBpmRangeTitle">BPM è¨“ç·´çµ±è¨ˆï¼ˆ5 BPMå€é–“ï¼‰</div>
                <div class="calendarBpmRangeGrid">
                  ${bpmRangeStats.map(range => {
                    // åˆ¤æ–­é¢œè‰²ï¼š4å°æ—¶=14400ç§’ï¼Œ2å°æ—¶=7200ç§’
                    let colorClass = '';
                    if (range.duration >= 14400) {
                      colorClass = 'bpmRangeGreen'; // >= 4å°æ—¶ï¼šç»¿è‰²
                    } else if (range.duration >= 7200) {
                      colorClass = 'bpmRangeAmber'; // >= 2å°æ—¶ï¼šç¥ç€è‰²
                    }
                    
                    return `
                    <div class="calendarBpmRangeItem ${colorClass}">
                      <div class="calendarBpmRangeLabel">${range.start}-${range.end}</div>
                      <div class="calendarBpmRangeValue">${formatDuration(range.duration)}</div>
                      <div class="calendarBpmRangeCount">${range.count}æ¬¡</div>
                    </div>
                  `;
                  }).join('')}
                </div>
              </div>
            `;
          }
          
          // æŒ‰é£æ ¼åˆ†ç»„æ˜¾ç¤º
          Object.values(byGroove).sort((a, b) => b.totalDuration - a.totalDuration).forEach(group => {
            const grooveLabel = GROOVE_PRESETS[group.groove]?.label || group.groove;
            html += `
              <div class="calendarSessionGroup">
                <div class="calendarSessionGroupTitle">${grooveLabel} <span style="color: var(--muted); font-weight: 500; font-size: 12px;">(${group.count}æ¬¡ Â· ${formatDuration(group.totalDuration)})</span></div>
                <div class="calendarSessionList">
                  ${group.sessions.map((session, idx) => {
                    const tags = [];
                    if (session.ghostMode) tags.push('<span class="calendarSessionTag">ğŸ‘» Ghost</span>');
                    if (session.progressiveMode) tags.push(`<span class="calendarSessionTag">â¬† ${session.bpm}â†’${session.finalBpm}</span>`);
                    if (session.swing > 0) tags.push(`<span class="calendarSessionTag">Swing ${session.swing}%</span>`);
                    
                    return `
                      <div class="calendarSessionItem">
                        <div class="calendarSessionHeader">
                          <div class="calendarSessionDuration">${formatDuration(session.duration)}</div>
                        </div>
                        <div class="calendarSessionInfo">
                          <div class="calendarSessionInfoItem">
                            <span class="calendarSessionInfoLabel">BPM</span>
                            <span class="calendarSessionInfoValue">${session.bpm}${session.progressiveMode ? ` â†’ ${session.finalBpm}` : ''}</span>
                          </div>
                          <div class="calendarSessionInfoItem">
                            <span class="calendarSessionInfoLabel">ç»†åˆ†</span>
                            <span class="calendarSessionInfoValue">${formatDivision(session.division)}</span>
                          </div>
                          ${session.cellModes && session.cellModes.some((m, i) => m !== session.cellModes[0]) ? `
                          <div class="calendarSessionInfoItem">
                            <span class="calendarSessionInfoLabel">æ¨¡å¼</span>
                            <span class="calendarSessionInfoValue">${session.cellModes.map(m => CELL_MODES[m]?.label || m).join(', ')}</span>
                          </div>
                          ` : ''}
                          ${session.swing > 0 ? `
                          <div class="calendarSessionInfoItem">
                            <span class="calendarSessionInfoLabel">Groove</span>
                            <span class="calendarSessionInfoValue">${session.swing}%</span>
                          </div>
                          ` : ''}
                        </div>
                        ${tags.length > 0 ? `<div class="calendarSessionTags">${tags.join('')}</div>` : ''}
                      </div>
                    `;
                  }).join('')}
                </div>
              </div>
            `;
          });
          
          calendarDayDetail.innerHTML = html;
        }
        
        // æ—¥å†äº‹ä»¶å¤„ç†
        if (calendarBtn) {
          calendarBtn.addEventListener('click', () => {
            calendarModal.classList.add('show');
            currentCalendarDate = new Date();
            renderCalendarStats();
            renderCalendar();
          }, { passive: true });
        }
        
        if (calendarCloseBtn) {
          calendarCloseBtn.addEventListener('click', () => {
            calendarModal.classList.remove('show');
          }, { passive: true });
          
          // ç‚¹å‡»èƒŒæ™¯å…³é—­
          calendarModal.addEventListener('click', (e) => {
            if (e.target === calendarModal) {
              calendarModal.classList.remove('show');
            }
          }, { passive: true });
        }
        
        if (calendarPrevMonth) {
          calendarPrevMonth.addEventListener('click', () => {
            currentCalendarDate.setMonth(currentCalendarDate.getMonth() - 1);
            renderCalendar();
          }, { passive: true });
        }
        
        if (calendarNextMonth) {
          calendarNextMonth.addEventListener('click', () => {
            currentCalendarDate.setMonth(currentCalendarDate.getMonth() + 1);
            renderCalendar();
          }, { passive: true });
        }
        
        const calendarTodayBtn = document.getElementById("calendarTodayBtn");
        if (calendarTodayBtn) {
          calendarTodayBtn.addEventListener('click', () => {
            currentCalendarDate = new Date();
            renderCalendar();
            updateDailyGoalProgress();
          }, { passive: true });
        }
        
        // ç›‘å¬è®­ç»ƒæ•°æ®æ›´æ–°
        window.addEventListener('trainingCalendarUpdated', () => {
          updateDailyGoalProgress();
          if (calendarModal.classList.contains('show')) {
            renderCalendarStats();
            renderCalendar();
          }
        });
        
        // åˆå§‹åŒ–æ¯æ—¥ç›®æ ‡è¿›åº¦
        updateDailyGoalProgress();
        
        // æ—¥å†æ‰“å¼€æ—¶æ›´æ–°è¿›åº¦
        if (calendarBtn) {
          calendarBtn.addEventListener('click', () => {
            updateDailyGoalProgress();
          }, { passive: true });
        }
      })();
    </script>
  </body>
</html>

